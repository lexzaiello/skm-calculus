* Content for explanation slides
** SK explainer

- Analogy: UW courses

UW courses have course GPA's and S / NS

- Calculating a student's GPA

#+BEGIN_SRC python
  my_grades = [4.0, 3.0, 3.5, "Satisfactory", "Not Satisfactory"]  

  # Dumb GPA calculation
  def gpa(grades):
        return sum(grades) / len(grades)

  # TypeError, since we have strings in our my_grades
  gpa(my_grades)
#+END_SRC

- This doesn't account for S / NS grades.

#+BEGIN_SRC python
  # S/NS grades are strings, need to handle specifically
  # All satisfactory grades get a 3.0
  # Not satisfactory gets zero
  def grade_s_ns(grade):
    if grade == "Satisfactory":
      return 3.0
    else
      return 0

  # Courses are graded on a curve. 20% bump, let's say.
  def grade_numeric(grade):
    return min(4.0, grade * 1.2)

  def gpa_all(grades):
    # Which GPA calculator to use for which kind of grade
    calculator_kinds = {
      str: grade_s_ns,
      int: grade_numeric
    }

    # Convert all grades to numeric
    numeric_grades = [ calculator_kinds(type(grade))(grade) for grade in grades]

    # Compute GPA
    return sum(numeric_grades) / len(grades)
        
#+END_SRC

- There's a lot of redundancy here. We can clean this up in a couple ways using lambda functions.

#+BEGIN_SRC python
  # All satisfactory grades get 3.0
  grader_satisfactory = lambda _: 3.0

  # All not satisfactory get 0.0
  grader_not_satisfactory = lambda _: 0.0

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return grader_satisfactory
    elif grade == "Not Satisfactory":
      return grader_not_satisfactory
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = [ grader_for(grade)(grade) for grade in grades]

    # Compute GPA
    return sum(numeric_grades) / len(grades)
#+END_SRC

- We can refactor this even further. Both of out "S/NS" grades discard the actual grade value. It's not important.
- They're "constant" functions. 3.0 is a constant, and so is 0.0

#+BEGIN_SRC python
  def constant(val):
    return lambda _: val

  # All satisfactory grades get 3.0
  grader_satisfactory = constant 3.0

  # All not satisfactory get 0.0
  grader_not_satisfactory = constant 0.0

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return grader_satisfactory
    elif grade == "Not Satisfactory":
      return grader_not_satisfactory
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = [ grader_for(grade)(grade) for grade in grades]

    # Compute GPA
    return sum(numeric_grades) / len(numeric_grades)
#+END_SRC

In SK, we refer to our "constant maker" as K.

#+BEGIN_SRC python
  def K(val):
    return lambda _: val

  # All satisfactory grades get 3.0
  grader_satisfactory = K 3.0

  # All not satisfactory get 0.0
  grader_not_satisfactory = K 0.0

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return grader_satisfactory
    elif grade == "Not Satisfactory":
      return grader_not_satisfactory
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = [ grader_for(grade)(grade) for grade in grades]

    # Compute GPA
    return sum(numeric_grades) / len(numeric_grades)
#+END_SRC

We can do even better. In a way, our grader_for function is also a constant function. It never returns grade. It checks what grade is, but the output isn't grade.

#+BEGIN_SRC python
  def K(val):
    return lambda _: val

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return K 3.0
    elif grade == "Not Satisfactory":
      return K 0.0
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = [ grader_for(grade)(grade) for grade in grades]

    # Compute GPA
    return sum(numeric_grades) / len(numeric_grades)
#+END_SRC

We still have some redundancy. We're saying "grade" a lot in this file.
For example, in =grader_for(grade)(grade)=, we're writing grade THREE TIMES in the same line.
We can condense this. In that line, all we're doing is taking grade and duplicaating it into grader_for.

#+BEGIN_SRC python
  def K(val):
    return lambda _: val

  def I(val):
    return lambda x: x

  def S(func1, func2):
    return lambda arg: func1(arg, func2(arg))

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return K 3.0
    elif grade == "Not Satisfactory":
      return K 0.0
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = map(S(grader_for, I), grades]

    # Compute GPA
    return sum(numeric_grades) / len(numeric_grades)
#+END_SRC

We're also doing this "duplicate" thing in our GPA calculation at the end.

#+BEGIN_SRC python
  def K(val):
    return lambda _: val

  def I(val):
    return lambda x: x

  def S(func1, func2):
    return lambda arg: func1(arg, func2(arg))

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return K 3.0
    elif grade == "Not Satisfactory":
      return K 0.0
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = map(S(grader_for, I), grades]

    # Compute GPA. What to put for ?
    return S(?, len)(numeric_grades)
#+END_SRC

#+BEGIN_SRC python
  def K(val):
    return lambda _: val

  def I(val):
    return lambda x: x

  def S(func1, func2):
    return lambda arg: func1(arg, func2(arg))

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return K 3.0
    elif grade == "Not Satisfactory":
      return K 0.0
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = map(S(grader_for, I), grades]

    # Compute GPA. What to put for ?
    return S(S(sum, divide), len)(numeric_grades)
#+END_SRC

Let's expand this:

#+BEGIN_SRC python
S(S(K divide, sum), len)(numeric_grades)

= S(K divide, sum)(numeric_grades)(len(numeric_grades))
= (K divide sum)(sum(numeric_grades))(len(numeric_grades))
= divide(snum(numeric_grades), len(numeric_grades))
#+END_SRC

Final program:

#+BEGIN_SRC python
  def K(val):
    return lambda _: val

  def I(val):
    return lambda x: x

  def S(func1, func2):
    return lambda arg: func1(arg, func2(arg))

  # Grading on a curve.
  # All numeric grades get curved up 20%
  grader_numeric = lambda grade: min(4.0, grade * 1.2)

  def grader_for(grade):
    if grade == "Satisfactory":
      return K 3.0
    elif grade == "Not Satisfactory":
      return K 0.0
    else
      return grader_numeric

  def gpa_all(grades):
    # Convert all grades to numeric
    numeric_grades = map(S(grader_for, I), grades]

    # Compute GPA. What to put for ?
    return S(S(sum, divide), len)(numeric_grades)
#+END_SRC
