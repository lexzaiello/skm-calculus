* Sk plan

Limitations of old approaches:
- Can't extract a "truth value" from M
  - Can't distinguish well-typed M from ill-typed
  - *New approach: constructive proof - you cannot produce M e t if e is not well-typed, since M e t will not type-check otherwise*
- Typings of K and S are complex
- Typings of K and S are the same as K and S
- M e t is the term representing "e is well-typed with type t"

M (M e) = M e t if e is well-typed

* Arrow abstraction / interpretation

- The only "base" types we have are M K, M S, and M M
- These don't actually reduce to anything
- We can interpret M (K \alpha \beta) as \alpha \rightarrow \alpha \rightarrow \beta
- We can interpret S similarly
- What is K \alpha, though?
  - We can just say this is SKM[((M K) \alpha)]
- But how do we unify arrows and just regular shit?
  - Do we even have to?
- How do we handle the beta-equivalent case?

* Arrow combinator

This is the holy grail. Adding a first-class arrow combinator.

* Arrow combinator functionality

We would like to have evaluation rules for ~> that behave similarly to \forall. We can do this if we derive the ~> expression via evaluation rules
We can do this the pure combinator way now, but I don't like this.
Point-free M K is nice.

* Fully dependent S and K, no partial M

K : #~>

K : #~>

K α : #~>

K α β : α ~> β
K α β x : α ~> 

K α β : #~> α β

K : S #~> #~>

K : #~>

K α : #~> α

K α : #~> α (#~> α)

K α β : #~> α (α β)

New S type just dropped?
There's this nice elimination we can do for this case
S : (#~> #~>) #~>
S α : α ~> (#~> #~>)
S α β : β ~> #~>
S α β γ : 

This is literally substitution.
We can just change the evaluation rule for ~>
such that ~> doens't pop the body. It just passes the argument through the type.

Wait ayo. We only pop the body of the ~> when a function call happens. When there's an eval step.

(t_in ~> t_out) arg = t_in ~> (t_out arg)

So S : (#~> #~>) #~>

K : #~> #~>
K α : (#~> #~>) α
K \alpha : #~> ~> \alpha
K \alpha \beta : #~> ~> \alpha \beta

Now when we evaluate K \alpha \beta x, lhs type becomes
~> \alpha \beta

Well, technically K \alpha \beta x is not an "eval step", whatever that means.

(t_in ~> t_out) arg = = t_in ~> (t_out arg)
(t_out <~ t_in) arg = = t_in ~> (t_out arg)

I think this is fine. But when do we pop to just t_out arg?
Intuitively, whenever we have a reduction.

*OR, we pop when there are no #~> left to fill.*
^^ I like this one.

This should actually be defined the same for K and S.

K : Ty 0 ~> Ty 0 ~> (S #~> #~>)
K \alpha : Ty 0 ~> Ty 0 ~> (\alpha ~> ((#~> \alpha))
K \alpha \beta : Ty 0 ~> Ty 0 ~> (\alpha ~> (\alpha ~> \beta))
K \alpha \beta x : Ty 0 ~> (\alpha ~> (\alpha ~> \beta))

Why can't we keep popping per-arg?

K : Ty 0 ~> Ty 0 ~> (S #~> #~>)
K \alpha : Ty 0 ~> S #~> #~> \alpha
K \alpha \beta : \alpha ~> (\alpha ~> \beta)

There's some incongruency here causing this.
But popping per-arg is fine.

We would just like to flip ~> in this type.
We could theoretically just add a <~ combinator.
Or we can just rework this expression somehow.

With <~, it's really clean though.

K : Ty 0 ~> Ty 0 ~> (S #~> <~#)
K \alpha : Ty 0 ~> \alpha ~> (<~# \alpha)
K \alpha \beta : \alpha ~> (\beta ~> \alpha)

We need to actually return \alpha though and discard our argument, since when we add x as an argument, it gets fed in.
K \alpha \beta x : \alpha ~> (\beta ~> \alpha x)

This is fine, I think.
For ergonomics we may want to remove the weird K thing we have to do at the end.

So the eval rule for ~> is
(\alpha ~> \beta) x = \alpha ~> (\beta x)

Except we don't know when \beta is a normal value.
So we do actually need K in the type of K.

K \alpha : Ty 0 ~> \alpha ~> (<~# (K \alpha)))
K : Ty 0 ~> Ty 0 ~> (S #~> (S <~# 

K \alpha : Ty 0 ~> \alpha ~> (<~# \alpha)

Mwah. Chef's kiss.

K : S #~> #~>
K \alpha : \alpha ~> (#~> \alpha)
K \alpha \beta : 

Why don't we just pop the types eagerly?
Like whenever you supply an argument, you pop the type?
This makes things a lot more complicated.
Perhaps have both?

ALTHOUGH. We could just not pop anything at all, but define the type of M recursively so that it does the popping then.

Ok so what about S?
We can do this nice type instantiation now with our arguments.

The question is, do we choose:
S (\alpha \beta \gamma : Type) : (\alpha \rightarrow \beta \rightarrow \gamma) \rightarrow (\alpha \rightarrow \beta) \rightarrow (\alpha \rightarrow \gamma)

or

S (\alpha \beta \gamma : Type) : \alpha \rightarrow \beta \rightarrow \gamma


This is lowkey ass because we have ZERO type information about the next step of evaluation.
But if we capture that somehow...

S (\alpha \beta \gamma : Type) : 

ALthough now that I think about it, now that we have arrows for our K and S, we don't need to split this up. We can just use the canonical one.

We need to control the order these are filled in.
We need to copy \alpha in one step.

Now this one is unironically nontrivial. Lol.

Fun fact though, \alpha ~> \beta ~> (\alpha ~> \gamma) = S (#~> (#~> \beta)) (<~# \gamma) \alpha = ((\alpha ~> (#~> \beta))) (\alpha ~> \gamma)
Fun fact though, \alpha ~> \beta ~> (\alpha ~> \gamma) = S (#~> \beta) (<~# \gamma) \alpha = (\alpha ~> \beta) (\alpha ~> \gamma)
Perhaps we can somehow join all these things up with ~> at the end.

So, for example, S (\alpha ~> \beta ~> \gamma) (\alpha ~> \beta) <~# (\alpha ~> \gamma) = <~# (\alpha ~> \beta ~> \gamma) (<~# (\alpha ~> \beta))

S \alpha : Ty 0 ~> Ty 0 ~> 

S : Ty 0 ~> Ty 0 ~> Ty 0 ~> 

S : Ty ~> Ty ~> Ty ~> S Ty Ty Ty 
S \alpha : Ty ~> Ty ~> S Ty Ty Ty \alpha
S \alpha \beta : Ty ~> S Ty Ty Ty \alpha \beta
S \alpha \beta \gamma : (\alpha \gamma) (\beta \gamma)

S : Ty ~> Ty ~> Ty ~> S (S #~> #~>) #~>
S \alpha : Ty ~> Ty ~> ((S #~> #~>) \alpha) (#~> \alpha)
S \alpha : Ty ~> Ty ~> (\alpha ~> (#~> \alpha)) (#~> \alpha)

We can potentially build the types incrementally.
So instead of copying \alpha into the fully type at once, we build it out in each step.
We really just need to know the "next input type." Not ALL the input types.

S \alpha \beta \gamma : (\alpha ~> \beta ~> \gamma) ~> 
X type has to match
S \alpha \beta \gamma x : #~> x
We need to "re-extract \alpha and \beta" from x. This is possible.
If we call x with some argument, the argument will be passed as a parameter to \gamma.

Ok, another strategy. We can build the type inside out.
We can build \alpha ~> \beta ~> \gamma out of y and (z : \alpha).
y : \alpha ~> \beta and z : \alpha 
So, theoretically, (M y) (<~# \gamma) = \alpha ~> \beta ~> \gamma

However, this is not predictive.
There is no specific reason why we can't have the types of S in reverse:
S : \alpha \beta \gamma, \alpha ~> (\alpha ~> \beta) ~> (\alpha ~> \beta ~> \gamma)
S \alpha \beta \gamma z y x = (x z) (y z)
However we're being extremely cheeky here, sine we haven't even constructed the types from the input type arguments.
We need to predict the ENTIRE type via the type arguments, then decompose.
We can add a new combinator for this if we want to. But I would prefer not to.

HOWEVER, like I said, we can build the type one argument at a time.
We just need to construct \alpha ~> \beta ~> \gamma first.

S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma) = ((#~> \alpha) (#~> \beta \gamma) = #~> #~>
S : <~# <~#
S \alpha = <~# <~# \alpha = \alpha #~> <#~
S \alpha \beta = \alpha #~> (<#~ \beta)
S \alpha \beta \gamma = \alpha ~> (\beta ~> \gamma)

So we know how to construt (\alpha ~> (\beta ~> \gamma)) now.
Getting (\alpha ~> \beta) is just popping the deepest nested \gamma, but we don't have an operation for that.

Creating \alpha ~> (\beta ~> \gamma) is pretty simple though. It's just <~# <~#.
So, logically, we can just copy \alpha and \beta when we do this.

S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)

Now, remember, we will pass x in, and it will be bubbled into \gamma.

"Return" within a ~>:

- When we're "finished" building a type, we need to "return" the value with K so that further type arguments don't get bubbled down.
For example, the type of K:

#+BEGIN_SRC lean
K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) <~#)
#+END_SRC

For \alpha \beta, this produces:

K \alpha \beta : (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) <~#) \alpha \beta
K \alpha \beta : (#~> \alpha) (<~# \alpha) \beta = \alpha ~> (<~# \alpha) \beta = \alpha ~> (\beta ~> \alpha)

For \alpha \beta x y, this produces:

K \alpha \beta x y : \alpha x y

This is not really what we wanted.
However, we can fix it in our (#~> \alpha) (<~# \alpha). Just replace the second one with (<~# (K \alpha))

However, we could potentially change the evaluation rules to handle this. Obviously, we should bubble if:

(t_in ~> t_out) arg

But theoretically, the output type might want to do something with the argument anyway. So we need to bring back !~>.

K \alpha \beta : (#~> \alpha) (<~# (K \alpha)) \beta
K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) (S (K <~#)) K))
K \alpha : Ty n ~> (\alpha ~> (<~# (K \alpha)))
K \alpha \beta :  (\alpha ~> (\beta ~> (K \alpha)))
K \alpha \beta x : \beta ~> (K \alpha x)
K \alpha \beta x y : (K \alpha x) y

K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) (S (K <~#)) (S (K K) K)))

K \alpha : Ty n ~> (\alpha ~> ((S (K <~#)) (S (K K) K)) \alpha))
K \alpha : Ty n ~> (\alpha ~> (<~# (K (K \alpha))))
K \alpha \beta : \alpha ~> (\beta ~> (K (K \alpha)))
K \alpha \beta x : \beta ~> K \alpha
K \alpha \beta x y : K \alpha y = \alpha

We need another K. 

** Dependent S Typing

We know how to produce (\alpha ~> \beta ~> \gamma):

#+BEGIN_SRC lean
S : Type m ~> Type n ~> Type o ~> (<~# <~#)
S \alpha : Type n ~> Type o ~> (#~> #~>) \alpha
S \alpha : Type n ~> Type o ~> \alpha ~> (#~>)
S \alpha \beta : Type o ~> \alpha ~> (#~> \beta)
S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)
#+END_SRC

We can produce \alpha ~> (\beta ~> \gamma) easily.
We can also produce \alpha ~> \beta easily. But, producing all 3 is very difficult.
A possible strategy for (\alpha ~> \beta) ~> (\alpha ~> \gamma):

Note that \alpha is duplicated, while \beta and \gamma aren't.

This is in essence: S (<~ \beta) (<~ \gamma) \alpha = (\alpha ~> \beta) (\alpha ~> \gamma)

But what about the ~> in between? This would seem complicated, but we can construct (\alpha ~> \beta) ~> (\alpha ~> \gamma) by #~> (\alpha ~> \beta) ~> (\alpha ~> \gamma).

#+BEGIN_SRC
So, (S (K ~>) (S (<~ \beta) (<~ \gamma))) α = (~>)
#+END_SRC

However, this does not have the parenthesization we want.


S (<~ \beta) (<~ \gamma) \alpha

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

The question is, do we even want this? We would like to be able to instantiate dependent types in shit like

(x z) (y z)

This typing appears to be just polymorphic.

We want:

S α β γ x y z : (((M x) z) (y z))

But we want to restrict inputs in some way.
S α β : (α ~> x_out) ~> (α ~> y_out) ~> S α 
S :  Ty 0 ~> Ty 0 ~> Ty 0 ~> (S Ty 0 Ty 0 Ty0)
S α β γ : (α γ) (β γ)

Really what we want is:
S α β γ x y z : (((M x) z) (y z))

This is not hard to achieve, but we need to restrict our inputs such that (x : α ~> ((M y) z))

But, we can't instantiate y and z, since we don't know what they are yet.

There isn't really a reason why we can't upgrade the type of S like such:

We can only really restrict types predictively.
We can't post-hoc restrict a type further. Or can we?
Really, I would like as minimal arguments to the function as possible.

What we want is:

S α β γ x y z : (α z) (y z)

Imagine they're popped off:

Ayo we're calling α here. Wtf.
This is possible if α is an arrow expression, because then it has type Ty.

- α z creates a new type
- y z creates a new term
- we can know the type of this already
- α z new type should expect ((M y) z) as an input
- So it's not clear what the type of x is immediately, since it expects y z as an input
- (y z) could be used to instantiate the type

- We can make assertions about x_out, though
- We may not be able to assert that the full type of x is α ~> β ~> γ,
but we can say that it expects α as an input, produces some output,

We can do type inference for S really easy:
M (S _ _ _ x y z) = ((M x) z) (y z)

Looking at this type, we can see x : M x, M x = α
We can see that α : γ 

S α β γ x y z : (α  ~> x_out) ~> (α ~> y_out) ~> α ~> (α z) (y z)

Also, another thing. Our typing judgment for α ~> β is kind of funky.
We really ought to separate the typing for ~> (pi) and →.
α → β is Ty whatever
while α ~> β is actually (M β). TODO

So, in ((M x) z) (y z),
(M x : α ~> 
(y : α ~> y_out)
(z : α)
(M x) : α ~> x_out
(x_out : (y_out α)

Is polymoprhic S actually polymorphic?
f
S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

There doesn't appear to be any dependency on terms in these types. Ngl.
Is this equivalent to ((M x) z) (y z)?

S α β γ x y z : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ ~> ((M x) z) (y z)

y : α ~> β
x : α ~> (β α) ~> γ
z : α

S α β γ y_out : (α ~> (y_out α) ~> γ α)

"Polymorphic" S actually is dependent, since it's not actually polymorphic. ~> does all the heavy lifting.

S α β γ :  (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ
S α β γ x y z : ((M x) z) (y z)
S α β γ x y z : ((α ~> β ~> γ) z) (y z)
S α β γ x y z : (γ z) (y z)

On to actually making the S type.

**** S is dependent, but how do we construct its type?

We can construct a type of the form α ~> β ~> γ pretty easily.

S : Type m ~> Type n ~> Type o ~> (<~# <~#)
S \alpha : Type n ~> Type o ~> (#~> #~>) \alpha
S \alpha : Type n ~> Type o ~> \alpha ~> (#~>)
S \alpha \beta : Type o ~> \alpha ~> (#~> \beta)
S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)

we'll say

def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

This makes α ~> (β ~> γ)

We can also make α ~> β. This is extremely simple. I'll use the same order of arguments, α β γ

def mk_ty := Type m ~> Type n ~> Type o ~> ~> ~>

mk_ty α β γ = ~> ~> α β γ = (~> ~> α) β γ = → ~> (α β) γ = (α β)

def mk_ty := Type m ~> Type n ~> Type o ~> ~> ~>

First with just α and β

def mk_ty_simple := Type m ~> Type n ~> ~>
mk_tysimple α β = α ~> β

Now we just discard γ.
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

^ Done.

mk_ty α β γ = (<~# K α β γ) = (α ~> K) β γ = (α ~> (K β)) γ = (α ~> β)


So, now we can construct (α ~> (β ~> γ)) and (α ~> β)

The rest of the type is literally just copiny γ and α.

Or, if we want, we can make a similar method to make this part of the call.

If we had something to "flip" K, that would be nice.
Or, alternatively, we can use →.
mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

^^ This works.

mk_ty_z α β γ = (~> →) α β γ = (→ ~> α) β γ = ~> α γ = α ~> γ

Ideally, we can compose these functions together to make the segments of the type.

We just need to duplicate α β γ each into each.
Let's make a α β γ "map" - this is just the functions we made


Catalogue: mk_t_x - (α ~> β ~> γ), mk_ty - (α ~> β), mk_tz - (α ~> γ)
Each of these accept α β γ as inputs.

To copy α, for example:
S mk_tx mk_ty α = (mk_tx α) (mk_ty α)
This is not particularly useful.

Simple algorithm: S already takes α β γ. We can use a fixpoint to duplicate in a way.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx
S α β γ = (α ~> β ~> γ) ~> 

Oh this is actually super simple.

Remember that (t_in ~> t_out) arg just pops one t_in, produces t_out arg
But we shouldn't just recurse like this forever.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx ~> mk_ty ~> mk_tz
S α : ~> Ty m (~> Ty n (~> Ty o (~> mk_tx (~> mk_ty mk_tz)

Evaluation here, α pops off the Ty m, we get (~> Ty n (~> Ty o (~> mk_tx (~> mk_ty mk_tz) α.
We don't want this to recurse forever. Our eval rule for (t_in ~> t_out) arg is broken. Really, it should be:
(t_in ~> t_out) arg = (t_in ~> t_out arg)
However, we should be able to use ((((M K) α β) x) y) and receive α

Quick recap of K type:

#+BEGIN_SRC lean
K : SKM[Ty m ~> Ty n ~> (((((S m.succ n.succ m (M (~>))) (M (<~))) Ty m) (~>)) (←))]
#+END_SRC

Same shit here, eval_once will work. K α : (Ty n ~> ...) α, but if we continue eval'ing this, we will pop ALL of the arguments.
We only want to pop once.

What happens if we fully evaluate K α?

#+BEGIN_SRC lean
K α : (((((S m.succ n.succ m (M (~>))) (M (<~))) Ty m) (~>)) (←)) α
K α : (~> α) (← α)
#+END_SRC

We can just insert Ty n deeper in here. We want Ty n ~> α (← α), such that
K α β : (α → α) α - this is wrong.

We could actually change the eval rues. We can just extend (t_in ~> t_out) arg := t_out arg to

t₁ ~> (t₂ ~> t₃) arg := (t₂ ~> (t₃ arg))
This is fine, ish, since now we're only ever obliviating one type.
Say we have t₁ ~> (t₂ ~> (t₃ ~> t₄)))), though

(t₁ ~> (t₂ ~> (t₃ ~> t₄))))) arg = (t₂ ~> ((t₃ ~> t₄) arg))

Ok, eval rules are fixed.

We could just algorithmically insert arg.

So, now, back to copying α β γ into our type constructors.

S (mk_tx mk_ty α = 

S : Ty m ~> Ty n ~> Ty o ~> 

S : (α ~> β ~> γ) ~> (α ~> β) ~> (α ~> γ)
S : Ty m ~> Ty n ~> Ty o ~> S (S mk_tx mk_ty) mk_tz

(S (S mk_tx mk_ty) mk_tz)  α β = (mk_tx α) (mk_ty α) (mk_tz α)

How do we do multiple variables tho...
S (S (mk_tx α) (mk_ty α)) (mk_tz α) β ..
this is the pattern.

How do we produce it?

(S (S (S mk_tx mk_ty)) mk_tz) α β = ((S (S mk_tx mk_ty)) α) (mk_tz α) = (S mk_tx mk_ty) (mk_tz α) (α (mk_tz α))

((S (S mk_t_x mk_t_y) mk_t_z) α) = ((S mk_t_x mk_t_y) α) (mk_t\z α) = ((mk_tx α) (mk_ty α)) (mk_t\z α)

S α : Ty n ~> Ty o ~> S (mk_tx α) (mk_ty α)
S α β : Ty o ~> S ((mk_tx α) β) ((mk_ty α) β)
S α β γ : (((mk_tx α) β) γ) (((mk_ty α) β) γ))

This is promising.



Other technique: we don't have to bbuild the type all at once. Do it in layers.

Or, hypothetically, we could extend our mk_twhatever with the ability to chain them together?

S α β γ : mk_t_x α β γ 

S (S (mk_t_x α β γ) (mk_t_y α β γ)) (mk_t_z α β γ) α β γ = (S (mk_t_x α β γ) (mk_t_y α β γ)) α (mk_t_z α β γ) α β γ
= (mk_t_x α) (mk_t_y α) (mk_t_z α) β γ

S (S (mk_t_x mk_t_y) (mk_t_z) α β γ

S (S mk_t_x mk_t_y) mk_t_z α β γ =
  (S mk_t_x mk_t_y) α (mk_tz α) β γ
= (mk_tx α) (mk_ty α) (mk_tz α) β γ

S (

Other approach, type by type

We can copy α here. We need to copy it three times.

S : Ty m ~> S (<~# <~# Ty n) (S ~> ~>)
S : Ty m ~> S (K (~> Ty n)) (S mk_tx mk_ty)
S α : S (K (~> Ty n)) (S mk_tx mk_ty) α = (~> Ty n) ((mk_tx α) (mk_ty α))

                                                                 ^ here
We want to add another layer for copying β in. We just need to insert an S

S : Ty m ~> S (K (~> Ty n)) (S (S (K S) mk_tx) mk_ty)
S α : Ty n ~> ((S (S (K S) mk_tx) mk_ty) α) = Ty n ~> ((S (mk_tx α) (mk_ty α)))
S α β = ((m_tx α) β) ((m_ty α) β)

Manually making this S type is going to be a fucking herculean task.

We already know we can make the type of x (α ~> β ~> γ).

Are there any other smart encodings we can come up with?

Really, the most important type is x. We just have to show that the rest are well-typed.

Once we have x as an input, we can test y and z using x,
since x has the type (α ~> β ~> γ).
We can probably even form (α ~> β) from it, since α ~> β ~> γ = (~> (~> (~> α) β) γ)
If we can inject K, we can do it.


S : Ty m ~> Ty n ~> Ty o ~> mk_tx ~> 

S : Ty m ~> S (K (~> Ty n)) (S (S (S (K (~> Ty o)) S) mk_tx) mk_ty)
S α : S (K (~> Ty n)) (S (S (S (K (~> Ty n)) S) mk_tx) mk_ty) α
    = (Ty n ~> (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α))

S α β : (Ty n ~> (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α)) β
    = (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α) β
    = (S (S (K (~> Ty n)) S) mk_ty (mk_tx mk_ty) α β
    = ((S (K (~> Ty n)) mk_ty) (S mk_ty) (mk_tx mk_ty) α β
    = ((K (~> Ty n) (S mk_ty)) (mk_ty (S mk_ty)) (mk_tx mk_ty) α β
    = ((mk_ty (S mk_ty)) (mk_tx mk_ty)) α β

S with 3 fanouts:
S : Ty m ~> S (K (~> Ty n)) (S (S (S (K S) mk_tx) mk_ty) mk_tz)
S α : Ty n ~> ((S (S (S (K S) mk_tx) mk_ty) mk_tz) α)
S α β : (((S (S (S (K S) mk_tx) mk_ty) mk_tz) α) β)
        = ((S (S (K S) mk_tx) mk_ty) α) (mk_tz α) β
        = ((S (K S) mk_tx) α) (mk_ty α) (mk_tz α) β
        = ((K S) α) (mk_tx α) (mk_ty α) (mk_tz α) β
        = S (mk_tx α) (mk_ty α) (mk_tz α) β
        
        

S α : S mk_tx mk_ty α = (mk_tx α) (mk_ty α)
For S α β, we just do S (mk_tx α) (mk_ty α) β instead
Then same for S α β γ

I really feel like we ought to decouple substitution from popping.
If we just do (α ~> β) arg, we should just get (α ~> (β arg)),
but if we do M of a call, then we trigger popping.

Well, we're in a type, so we should trigger popping.
There's also another possibility which is that we introduce yet another arrow.
But I don't like this.

S α : (Ty n ~> α (α ~> (~> α))) 



S : Ty m ~> Ty n ~> Ty o ~> S 

We can chain these together by making mk_tx copy its arguments to a callee (golly gee this is getting really complicated though).

* When to trigger "substitution" vs popping

- (α ~> β) arg should be treated as substitution
- ((M e) arg) where (e : α ~> β) should invoke "popping"

This is a nice barrier between head reduction and reduction within the expression.

For example, with the type of K:

#+BEGIN_SRC lean
K α : Ty n ~> (((((S _m.succ n.succ _m (M (~>))) (M (<~))) Ty _m) (~>)) (←)) α
K α β : (((((S _m.succ n.succ _m (M (~>))) (M (<~))) Ty _m) (~>)) (←)) α β
K α β : (~> α) (← α) β = (α ~> (← α)) β = β → α
#+END_SRC

This would also simplify the typing of S significantly, since we would be able to manipuatel the full type of =S= in multiple passes without losing structure. Note, however, that items will still be popped in that case, since any arguments will necessarily invoke popping.

We gotta fix the K type, since it's discarding one of the α.

S α β γ : (α ~> β ~> γ) ~> whatever

This "no-pop feature" seems really important. Would make the typing for K really really clean.

Would be what I need to make this work.

#+BEGIN_SRC lean
K : Ty n ~> Ty m ~> S ~> <~
#+END_SRC

The question is, where do we pop if not in eval for (t_in ~> t_out) arg?
Most obvious candidate: evaluation, though this is not necessarily true.
Just type-checking a function call will probably invoke pop.
So, generalize to all function calls.

Essentially, (((M K) α β) x y) just does substitution, but (M (K α β x y)) does the actual popping.

So, the rule is M (lhs rhs), pop lhs's type.

The question is what to do about →?
I think the same should hold.

I really don't want to make this retarded like "pop" combinator. 
Is there a way to represent it?

Essentially taking an expression of the form α ~> β and turning it into β?
This is represented as ((~> α) β).
We don't necessarily need a pop combinator. If our left-hand-side type eval's to a ~>, we just pop it.

Popping is separate from substitution now.

Now, we can use this really nice K typing:

#+BEGIN_SRC lean
K : (Ty n ~> Ty m ~> S ~> <~)
K α : Ty m ~> (S ~> <~ α)
K α β : (S ~> <~ α) β
K α β : (~> α) (<~ α) β = (α ~> (<~ α)) β = α ~> (β ~> α)
#+END_SRc

* Potential improvements to S type with new "substitution" vs "popping" mechanism

Now that substitution is separated from "popping" (not sure what to call this lol), defining the type of S may be simpler, since we may be able to "backtrack."

S \alpha \beta \gamma : (\alpha ~> \beta ~> \gamma) ~> (\alpha ~> \beta) ~> (\alpha ~> \gamma)

Now that we seperate substitution, we may be able to leverage the type of x to define the type of y and z.

We still have access to our mk_tx function defined above.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx

S \alpha \beta \gamma : Ty m ~> Ty n ~> Ty o ~> (\alpha ~> \beta ~> \gamma)

S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> ((\alpha ~> \beta ~> \gamma) x)
S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> ((\alpha ~> \beta ~> \gamma) x)

It would be really cool if we had some primitive to manipulate types. That is, if we could just drop the ~> \gamma from the type of x, we can easily make the type of y.

S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> (\alpha ~> \beta ~> \gamma) ~> (some transformation to remove \gamma (M x))

A potential way to remove \gamma from (M x): we can bubble down a K into its type.

This doesn't get us anywhere, since the evaluation rule for ~> puts our argument after the type.

S α β γ x : Ty m ~> Ty n ~> Ty o ~> (α ~> β ~> γ) ~> (M x)

I don't want to just add random evaluation rules to fix this issue.

Theoretically we could change the order of the arguments.
If we put z first (HIGHLY UNORTHODOX), we can build the type of x out of y and z.
BUT, this is suboptimal, since it isn't true to SK.

Just run with it though.

S' α β γ : Ty m ~> Ty n ~> Ty o ~> α ~> (α ~> β) ~> γ

Here, we're not really doing any crazy duplication. We can just form the type α ~> β ~> γ from the arguments we have.

If we have α, we can easily make α ~> β.

Going back to our mk_tx, mk_ty, mk_tz, we can probably copy all of our arguments into these. 

We can probably alter our little type maker combinators to not require all 3 arguments.

mk_tx just takes in α β and γ.
mk_ty just takes in α and β
mk_tz just takes in α and γ

Really, the only thing we need to copy three times is α.

Here, we copy α 3 times.
S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

S α : Ty m ~> Ty n ~> Ty o ~> ((α ~>) (α ~>)) (α ~>) = (α ~> (α ~>)) (α ~>)

Recall that there is actually an evaluation rule here we need to do, since we're passing an argument to α ~> (α ~>)

(α ~> (α ~>)) (α ~>) = α ~> (α ~> (α ~>))

This is actually fine. We can copy β now. Would have to be something like:

S (~> α) (~> α) β = (α ~> β) (α ~> β)

And then from here, we can embed logic into the left and right α ~> β to reject or accept γ.

(α ~> (~> β)) (α ~> (K β))

If we pass in γ, we get:

S (α ~> (~> β)) (α ~> (K β)) γ = (α ~> (β ~> γ)) (α ~> β)

This is exactly what we want.

So, going back to this step, how do we wrap it all together?

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

This step allows us to get α ~> (α ~> (α ~>))

Howver, note that associativity gives us:

(α ~>) (α ~> (α ~>))

This is fine.

We just need to put a placeholder in the third α ~> spot so we can fill it with β.

Something like:

(α ~>) (S (α ~> ) (K (α ~>)))

If we feed β into this we get:

S (α ~>) (S (α ~> ) (K (α ~>))) β = (α ~> β) ((α ~> β) (α ~>))

Now, since we're going to be copying in γ next, we just need to reject γ from the middle α ~> β

S (α ~>) (S (α ~> K) (K (α ~>))) β = (α ~> β) ((α ~> (K β)) (α ~>))

We also need to "accept" γ in the left α ~> β by turning α ~> β into α ~> (~> β). This is pretty easy.

S (α ~> ~>) (S (α ~> K) (K (α ~>))) β = (α ~> (~> β)) ((α ~> (K β)) (α ~>))

#7 Now, we can copy in γ.

S (S (α ~> (~> β)) ((α ~> (K β))) (α ~>) γ = (((α ~> (~> β)) γ) ((α ~> (K β)) γ) (α ~> γ) = (((α ~> β ~> γ) (α ~> β) (α ~> γ))

Technically, there is a reduction that can be done here.

(((α ~> β ~> γ) (α ~> β) (α ~> γ)) = (α ~> β ~> γ (α ~> β)) (α ~> γ)) = (α ~> β ~> γ (α ~> β) (α ~> γ)).

The only missing step is we need to append ~> in x and y.

Note, however, that we want these to be parnthesized correctly.

(α ~> β ~> γ (α ~> β) (α ~> γ)). = ~> α (~> β (~> γ (~> α β) (α ~> γ)

This is not really what we want. We want α ~> β ~> γ in parenthesis.

So really what we want is:

(~> α (~> β γ))

To recap:

1. Clone α 3 times

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>
S α : Ty m ~> Ty n ~> Ty o ~> (~> α) (~> α) (~> α)

This is perfect.

2. Rejection / accepting

We need to set up the first ~> α to accept β and γ, the second to reject γ, and the last to reject β.

Since β is the next argument, we must add the rejection logic in z and the type constructor logic in x and y.

We don't actually need "accept" logic in y. We just need to discard further arguments. K suffices.

S α : Ty m ~> Ty n ~> Ty o ~> (~> α (~>)) (~> α K) (~> α)

S : Ty m ~> Ty n ~> Ty o ~> S (S (<~# ~>) ~>) ~>
S α : Ty m ~> Ty n ~> Ty o ~> (α ~> (~>))  (~> α) (~> α)

Scratch:
S (<~# <~#) ~> α = (<~# ~> α) (~> α) = (α ~> (~>))  (~> α)

3. β accept x y

Using our new type, we can copy β. However, to copy β, we will need to nest the above expression in S.

Ideal:
S α β : Ty m ~> Ty n ~> Ty o ~> ((α ~> (~>)) β) ((~> α) β) (~> α)

We don't necessarily need to explicitly encode "rejection" of β in z.


S : Ty m ~> Ty n ~> Ty o ~> S (S (K S) (S (<~# ~>) ~>)) ~>
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S (<~# ~>) ~>)) α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (S (<~# ~>) ~> α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (S (<~# ~>) ~> α) (~> α)
S α β : Ty m ~> Ty n ~> Ty o ~> ((S (S (<~# ~>) ~> α) (~> α)

Our S is nested at the wrong level. We want to copy β. What's this extra S for again?


S : Ty m ~> Ty n ~> Ty o ~> S ((S (<~# ~>) ~>)) ~>
S α : Ty m ~> Ty n ~> Ty o ~> (((S (<~# ~>) ~>)) α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((((<~# ~>) α) (~> α))) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((((α ~> (~>)) (~> α))) (~> α)

This is looking pretty good. We want to be able to clone β once it gets passed through.

Note again the reduction here.
S α : Ty m ~> Ty n ~> Ty o ~> ((((α ~> (~>)) (~> α))) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((((α ~> (~> ~> α (~> α)))))

Idk what the hell is going on here. It clearlly is wrong. Lol.


Note that even in step #1, there is still a possible reduction
S α : Ty m ~> Ty n ~> Ty o ~> (~> α) (~> α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> (~> (α (~> α (~> α)))
Very obviously not what we want. We need to separate these babys.

S α : Ty m ~> Ty n ~> Ty o ~> (~> α) ~> (~> α) ~> (~> α)

Something like this. Note, however, that if we do this, copying will be way harder. I think the best approach is:

S α : Ty m ~> Ty n ~> Ty o ~> S (S (~> α) (~> α)) (~> α)
S α β : Ty m ~> Ty n ~> Ty o ~> (α ~> β) (α ~> β) (α ~> β)

This is a general skeleton for how we do this.

Just note that this step, too, should produce some S expression.
Also note that z should reject β.

Rejecting:

(S (K K) ~>) α = K (~> α), all β will be rejected

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)

We can see here that β would be rejected from z, but γ would be accepted.

Fan out:

S : Ty m ~> Ty n ~> Ty o ~> S (S (K S) (S ~> ~>)) (S (K K) ~>)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S ~> ~>)) α) ((S (K K) ~>) α)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S ~> ~>)) α) (K (~> α))
S α : Ty m ~> Ty n ~> Ty o ~> (((S ((S ~> ~>) α)) (K (~> α))
S α : Ty m ~> Ty n ~> Ty o ~> (((S ((~> α) (~> α)) (K (~> α))
S α β : Ty m ~> Ty n ~> Ty o ~> (((S ((~> α) (~> α)) (K (~> α))
We need another S inside.
S α β : Ty m ~> Ty n ~> Ty o ~> (((~> α) (~> α) β) ((~> α))

S : Ty m ~> Ty n ~> Ty o ~> S (S (K S) (S (K S) (S ~> ~>))) (S (K K) ~>)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S (K S) (S ~> ~>))) α) (K (~> α))
S α : Ty m ~> Ty n ~> Ty o ~> ((S (S (α ~> (~> α))) (K (~> α))
S α β : Ty m ~> Ty n ~> Ty o ~> ((S (α ~> (~> α))) β) (~> α)
S α β : Ty m ~> Ty n ~> Ty o ~> ((S (α ~> (~> α))) β) (~> α)

I think the S is in the wrong place. It should be INSIDE the (α ~> ...) parenthesis.

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)
S α : Ty m ~> Ty n ~> Ty o ~> ((S ~> ~>) α) (K (~> α))
No, it's supposed to bbe like S (~> α) (~> α)

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)
S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)
S (M K) (M S) : ((Type 0 ~> (Type 1 ~> (Type 2 ~> (((S₀ ((S₀ ~>) ~>)) ((S₀ (K₀ K₀)) ~>)) (M K₀))))) (M S₀))

S (M K) (M S) (M M) : (((Type 0 ~> (Type 1 ~> (Type 2 ~> (((S₀ ((S₀ ~>) ~>)) ((S₀ (K₀ K₀)) ~>)) (M K₀))))) (M S₀)) (M M))

When we substitute, we should(?) reduce?
If we were to pop, we would reduce.
We should be lazy.

S (M K) (M S) (M M) : Type m ~> Type o ~> Type n ~> ((((((S₀ ~>) ~>) (M K₀)) (((S₀ (K₀ K₀)) ~>) (M K₀))) (M S₀)) (M M))

S (M K) (M S) (M M) : ((M K₀) ~> ((M K₀) ~> (((((S₀ (K₀ K₀)) ~>) (M K₀)) (M S₀)) (M M))))

We should be reducing here as well, idk why we're not.

S ? ? ? : (Type 0 ~> (Type 1 ~> (Type 2 ~> (? ~> (? ~> (? ~> ?))))))

S Ty 10 Ty 11 Ty 20 : (Type 0 ~> (Type 1 ~> (Type 2 ~> (Type 10 ~> (Type 10 ~> (Type 10 ~> Type 20))))))

Key idea:
- Fan out α β γ
- For each, "reject" or "accept"
- We already have utilities for this: mk_tx, mk_ty, and mk_tz

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> (α ~> γ)
Technically this is actually just:
(α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

Order of arguments is the same for all three. We just need to reject γ in y, and reject β in (α ~> γ)

We need to design 3 functions that take α β γ and produce their types. We already have this.

Gives us α ~> β ~> γ
def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

Gives us (α ~> β)
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

Gives us α ~> γ
def mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

To "compose these", we just need to put ~> around mk_tx, and ~> around mk_ty and mk_tyz
~> (mk_tx α β γ) ((~> mk_ty α β γ) (mk_tyz α β γ))

This gives our full type.
To combine these expressions, make a def.

def combine := ~>
combine left right = left ~> right

To combine all three given x y z,
~> ~>
~> ~> x y z = (~> ~> x) y z = (~> ~> (x y)) z
So we need
~> <~# x y z = (~> <~# x) y z = (<~# ~> x) y z = (x ~> ~>) y z = (x ~> (~> y)) z = (x ~> (y ~> x))

Exactly.

-- Combines x y z with ~>
Combine := ~> ~>

mk_tx, mk_ty, mk_z


Now, we need to "fan out" α β γ to each.
S (S mk_tx mk_ty) mk_tz
This will fan out α to all 3. But we want to fan out β and γ as well.

-- This is "fan out"
S (S (K S) (S (K S) (S (K K) S))) (K (S K K))

But, I don't really like this.

S (S mk_tx mk_ty) mk_tz α = (mk_tx α) (mk_ty α) (mk_tz α)

All of our type "maker" functions are combinators.
None of them individually use S.

We can modify mk_tx to prepend S inside mk_tx

Really, it would be great if we could avoid S altogether, but that's not happening.

This fan out shit is hella ugly, ngl.
We can embed S inside mk_tx and it may be nicer.

mk_tx α β γ = (α ~> β ~> γ)

mk_tx α = (<~# α) (<~# α)

Really, we don't need to actually fan out everything.

S : (α ~> β ~> γ) ~> (α ~> β) ~> (γ ~> α)

We definitely need to fan out α,
but we only need to fan out β and γ once.

We can actually change the type signatures of all three so they only take their proper arguments.

mk_ty := ~>
mk_tz := <~#

So now we can fan out α

S : S (S mk_tx mk_ty) mk_z
S α : (mk_tx α) (mk_ty α) (mk_z α)

Now we only have to fan out β and γ once.
Note that we have our nice ~> operator.

(t_in ~> t_out) arg = t_out arg, under type-checking, otherwise it's just (t_in ~> (t_out arg))

We can kinda separate our concerns by "pipelining" (mk_tx α) (mk_ty α) (mk_z α) with ~>
Type o ~> S (S mk_tx mk_ty) mk_z

This copies α into all three.
If we do our "combine" first, we can probably fix shit up.

(mk_tx α) ~> (mk_ty α) ~> (mk_tz α)

Passing in another value will ONLY put it into mk_tz α
~> kinda behaves like λ lowkey

We can change our type signature a bit. Instead of creating the whole type at once,
we can create (α ~> β ~> γ), but copy α β γ WHILE inside, and put that shit after ~>

S α β γ : Ty m ~> Ty o ~> Ty n ~> mk_tx

Pair := S (K (S I)) K

So,
(Pair (Pair mk_tx mk_ty) mk_tz) 

OHHHHH we can make a pair out of α β γ

S : Type 0 ~> Type 1 ~> Type 2 ~> Pair Pair Pair
Pair α β Pair = Pair α β
Pair (Pair α β) = S (K Pair) Pair 
S (K S (K Pair)) Pair α = (S (K Pair)) (Pair α)
S (K S (K Pair)) Pair α β = Pair (Pair α β)

S (K S (K Pair)) Pair - this is what we need to make ((α, β), γ)

((α, β), γ) (S (K ~>) ~>) = (S (K ~>) ~>) (α, β) γ
= ~> ((α, β) ~>) γ

We probably want (α, (β, γ)) instead


Pair (Pair α β)

S (K S (K Pair)) Pair α β = Pair (Pair α β)

Thsi is a ridiculous amount of abstraction.

Our mk_tx, mk_ty, mk_tz are pretty simple.
None of them have S.

We will need S somewhere.

We will probably need to use mk_tx, mk_ty, mk_tz.

However, we don't need to have all arguments for all of them.

mk_tx stays the same
mk_ty := ~>
mk_tz := <~#

Copying α to all 3 is easy

S (S mk_tx mk_ty) mk_z

Low-key copying is easy in general. We can keep the old arguments version if we want.

def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

Gives us (α ~> β)
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

Gives us α ~> γ
def mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

S (S mk_tx mk_ty) mk_tz

We just need to stick another S in front after, so like..

S (S (K S) (S mk_tx mk_ty)) mk_tz

So, this with α β =
S (S (K S) (S mk_tx mk_ty)) mk_tz α = S (mk_tx α mk_ty α) (mk_tz α)

Excellente. we need another S on the inside tho.
S (S (K S) (S mk_tx mk_ty)) mk_tz
S (S (K S) (S (K S) (S mk_tx mk_ty))) mk_tz

S (S (K S) (S (K S) (S mk_tx mk_ty))) mk_tz α = S (S ((mk_tx α) (mk_ty α)) (mk_tz α)

bruh.
This is NOT what we want. We want:
S (S (mk_tx α) (mk_ty α) (mk_tz α)


S (S (K S) (S mk_tx mk_ty)) mk_tz α = S (mk_tx α mk_ty α) (mk_tz α)

Im not even gonna lie man, writing out the types for this shit finna be insane.

S (S (K S) (S (S mk_tx) mk_ty)) mk_tz
S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz α = S (mk_tz α)

Checkpoint  1.

S (S (K S) (S mk_tx mk_ty)) mk_tz

((((mk_tx α) (mk_ty α)) β) ((mk_tz α) β))

Need to stick an S in the middle, like I said, but at least we know this one's working.

Sticking the S inside: checkpoint 2.

We want:
((((S (mk_tx α)) (mk_ty α)) β) ((mk_tz α) β))

This happens when we copy α.
Something like S (K S) mk_tx α = S (mk_tx α)

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz

with args, gives us:

((((mk_tx α) β) ((mk_ty α) β)) ((mk_tz α) β))

Checkpoint 2. Fanout with β works with all 3.

Now we just repeat the process one more time.

(S ((S ((mk_tx α) β)) ((mk_ty α) β)) ((mk_tz α) β))

This allows us to stick the S in front of mk_tx, but we need an outer one somewhere.
S (S (K S) (S (S (K S) (S (K S) mk_tx)) mk_ty)) mk_tz

Probably around the inner and mk_ty
S (S (K S) (S (S (K S) (S (S (K S) mk_tx)) mk_ty))) mk_tz

Gives us:

Where did \alpha go? Lol.

((((mk_tx γ) ((mk_ty β) γ)) ((β γ) ((mk_ty β) \gamma))) ((mk_tyz \beta) \gamma))

This copies \gamma to mk_tx and mk_ty
We need to copy at the outer layer, too.
S (S (K S) (S (S (K S) (S (K S) mk_tx)) mk_ty)) mk_tz

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz
S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz α
 = (((S (K S) (S (S (K S) mk_tx) mk_ty))) α) (mk_tz α)
= (S ((S (S (K S) mk_tx) mk_ty) α)) (mk_tz α)
= (S (((S (K S) mk_tx) α) (mk_ty α))) (mk_tz α)

At this step, we need to do what we did on the first step
? = (S (((S (mk_tx α) (mk_ty α))) (mk_tz α)

We need the α step to produce
S (S (K S) (S (S (K S) (mk_tx α)) (mk_ty α))) (mk_tz α)

α step currently produces this:
= (S (((S (K S) mk_tx) α) (mk_ty α))) (mk_tz α)
= (S ((S (mk_tx α)) (mk_ty α)) (mk_tz α)

We want:
S (S (K S) (S (S (K S) (S (K S) (mk_tx α))) (mk_ty α))) (mk_tz α)

We can change the original expression to:
S (S (K S) (S (S (K (S (K S))) mk_tx) mk_ty)) mk_tz
This adds the K S before (mk_tx α)
? = (S (((S (K S)) (mk_tx α)) (mk_ty α)) (mk_tz α)
S (S (K S) (S (S (K (S (K S))) mk_tx) mk_ty)) mk_tz

We need to stick another S (K S) before the child stuff inside
        ↓ this is where we stick the outer S in
        ↓        ↓ here, we stick the middle S (K S)
S (S (K S) (S (S (K (S (K S))) (S (K (S (K S))) mk_tx)) mk_ty)) mk_tz

Testing it out.

(((((mk_ty ((S₀ (K₀ (S₀ (K₀ S₀)))) mk_ty)) mk_tz) α) (((mk_x mk_ty) mk_z) α)) β)

Going back to checkpoint.

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz

with args, gives us:

((((mk_tx α) β) ((mk_ty α) β)) ((mk_tz α) β))

Shouldn't be hard to add γ.
We just need:

(S (S ((mk_tx α) β) ((mk_ty α) β)) ((mk_tz α) β))

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz

Is there a smarter way of doing this?

Just copy α like: (~> α) (~> α) (~> α)

Then propogate β and reject from the last one:

 (α ~> ~>) (α ~> K) (K (~> α))

Need to copy tho.

In an expression like:
(~>) ~> (~>), it would be cool if in one pass you could copy the argument to all arrows

Basically every arrow that doesn't have an entry gets one.

This is only different from our current system in that we'd go down the left tree as well.

This shouldn't really be a problem, since types should be popped anyway.

Let's take an example:

S : Ty m ~> Ty o ~> Ty n ~> (~> ~>)
S α : (Ty m α) ~> (Ty o α) ~> (Ty n α) ~> ((~> α) (~> α))

This is low-key cracked.
Does this break our current K typing?

K : Ty m ~> Ty n ~> (S (~>) (<~#))
K α : (Ty m) α ~> (Ty n α) ~> (S (~>) (<~#) α)
K α : (Ty m) α ~> (Ty n α) ~> (α ~> (<~# α))

No.

K Typing still works.

This is nice.

However, this doesn't really fix anything.
We can use I for this.

S : Ty m ~> Ty n ~> Ty o ~> (I ~> I ~> I)
S α : Ty m ~> Ty n ~> Ty o ~> (α ~> α ~> α)
S : Ty m ~> Ty n ~> Ty o ~> ((~>) ~> (~>) ~> I)
S α β : Ty m ~> Ty n ~> Ty o ~> ((α ~> β) ~> (α ~> β) ~> (α β))

This is so nice.

S : Ty m ~> Ty n ~> Ty o ~> ((<~# ~>) ~> (~>) ~> I)
something should give us
S α : ... ~> ((K (K α) ~> ~>) ~> (~> (K α)) ~> α)
We need a K before 

Generally, we need 3 k's before α

S (K K) K α = K (K α)

S α : .. ~> S (type goes here) S (K K) K
S α : .. ~> S (K ((<~# ~>) ~> (~>) I)) S (K K) K
S α : ... ~> (<~# ~> (K (K α))
S α : ... ~> ((K (K α) ~> ~>) ~> (~> ((K (K a)))) ~> ((K (K a)))
S α β : ... ~> ((K α) ~> (~> β)) ~> (~> ((K (K a)))) ~> ((K (K a)))

We actually only need 2 K's in the first one, only 1 in the other two.

S α β : ... ~> ((K α) ~> (~> β)) ~> (((K (K a))) ~> β) ~> ((K (K a)))

S α β : ... ~> ((K α) ~> (~> β)) ~> (((K (K a))) ~> β) ~> ((K (K a)))

Need to add a K for β as well, but we only need 1 K for the middle one.

To add the two K's we do

S (K K) K

For the x type: S (K (<~# ~>)) (S (K K) K)

For the y type: S (K ~>) K

Need to reject β
Need to produce (K (~> (K α))

For the z type: S (K K) (S (K ~>) K)

S : ... ~> (S (K (<~# ~>)) (S (K K) K)) ~> (S (K ~>) K) ~> (S (K K) (S (K ~>) K))
S α : ... ~> ((<~# ~>) (K (K α))) ~> (~> (K α)) ~> (K (~> (K α))
S α : ... ~> ((K (K α)) ~> ~>) ~> (~> (K α)) ~> (K (~> (K α))
S α β : ... ~> ((K α) ~> β) ~> ((K α) ~> β) ~> ((~> (K α))
S α β γ : ... ~> (α ~> (β γ)) ~> (α ~> (β γ)) ~> (α ~> γ)

Checkpoint: need to put a ~> in x for γ and reject γ in y.

y type fix.
current: (S (K ~>) K)
for α β, this produces α ~> β.
We want α ~> (K β)
current: (S (K ~>) K)
(S (K ~>) K) α = ~> (K α)
Extend this to S (K (~> (K α))) (S (K ~>) K)

So, y type := S (S (K S) (S (K K) (S (K ~>) K)) (K K)

S : ... ~> (S (K (<~# ~>)) (S (K K) K)) ~> (S (K ~>) K) ~> (S (K K) (S (K ~>) K))

S : ... ~> (S (K (<~# ~>)) (S (K K) K)) ~> (S (S (K S) (S (K K) (S (K ~>) K)) (K K)) ~> (S (K K) (S (K ~>) K))

Checkpoint: y type with α β now produces (K α) ~> (K β). This is correct, and will reject γ. Note that we still need a ~> for (K β).

Now, for the x type.

Current: S (K (<~# ~>)) (S (K K) K)
S (K (<~# ~>)) (S (K K) K) α β = (K α) ~> β

We need to put a K around β
This is very similar to what we did with x.

In fact, this is very similar to the type for x. I think it might be:
S (S (K S) (S (K K) (S (K ~>) K)) (K K)

We might not actually need the K here
y type is just this but with an extra ~>

This is the x type
x type := S (S (K S) (S (K K) (S (K ~>) K)) (~>)

y type := S (S (K S) (S (K K) (S (K ~>) K)) (K K)

z type already established := S (K K) (S (K ~>) K)

S : Ty m ~> Ty n ~> Ty o ~> (S (S (K S) (S (K K) (S (K ~>) K)) (~>)) ~> (S (S (K S) (S (K K) (S (K ~>) K)) (K K)) ~> (S (K K) ~>))

For z type, seems like we don't need the K around \alpha.
z type already established := S (K K) ~>

In theory, we should just be able to combine these suckers.

* ~> cannot actually type-check in some cases because

~> copies to left and right hand side of ~> tree.

For example:
K \alpha \beta x : \beta x -> ...

What happens if \alpha = (M K) and we supply x and y to it?

We get
x ~> (y ~> x)

Thsi is kind of bizarre, but kind of cool.
Does this affect type-checking? Not really.
This simplifies our typing a typing a little bit.
Except, note that \beta also receives x.

Assume \beta = (M K)

We get
x ~> (y ~> x)

This is again, kind of cool. It's like \forall substitution.
However, if we input K, we should get the type, not the value.

This as it is would produce x ~> (y ~> x) as the type

\alpha shouldn't really be instantiated, since this is nondependent.
This is good news for S though.

* Mechanics of ~> substitution

~> substitutes arguments into input types and output types. This mirrors the calculus of constructions.
→ does not substitute, and (α → β) x = β, similarly to → in the CoC.

A nice abstraction could b ea "return" operator so that we can do stuff ~> return b

This is pretty much just K ? α β
We can fill this in fully. Almost.
We need to know the input type, which is a minor limitation.
If we're immediately on the right hand side of a ~>, we can infer it.

(α ~> return β) x = α x ~> return α

This is syntax sugar for K ? α β

We can even do this point-free. Well, we can't actually.
No we can't.

return is nice syntax sugar

α ~> return 

Maybe call it "always" instead

Obviously, always only works for the current ~>

* TODO Todos

** Type of S must be S : (K (M Ty m) Ty m Ty m) ~> (K Ty n) ~> (K Ty o) ~> ...

Manually filling in types is very cumbersome.
We can probably write something to "fill in" types.

We can generalize the algorithm for ?

Type inference is impossible for now, since we don't even have the types of K and S stabilized.

Can we define the type of K without ~>?

Also, idea. We can just specify type universes for →.

→ Ty m Ty n α β = K Ty m Ty n ~> K Ty m Ty n
Yes, we can derive →
→ = K ~> K

Need to flip the left side.
S K I

Wait, this is eta expanded.
This is slightly more complicated than I thought, but it's fine.

→ Ty m Ty n α β = Ty m

-- This gives us α on the left at the end
-- We want β on the right hand side
-- This use of id is wrong
S (K K) I Ty m = K (I Ty m)
K (I Ty m) α = (I Ty m)
(I Ty m ) β = β

Yeah. what? This is all wrong.
We need to also reject the argument.

Wait oh shit!!!

→ = ~>

→ α β = α ~> β

So we can probably do some shit like:

→ α β = K α ~> K β

This is kind of hairy to fill the type arguments of. Ngl.

→ α β = K Ty m α α ~> K Ty n α β

We can already fill in Ty m and Ty n with eta expansion.

→ Ty m Ty n = K Ty m ~> K Ty n
Now when we apply α we get
→ Ty m Ty n α = K Ty m α ~> K Ty n α
This is exactly right

Just for the β case, we need some magic
→ Ty m Ty n α β = K Ty m α β ~> K Ty n α β

We need to switch β here.

→ Ty m Ty n α β = K (K Ty m α α) β ~> K Ty n α β

left hand side:

S (K Ty m) (I Ty m) α = K Ty m α α
S (M (K Ty m)) (M (I Ty m))

Sot this is for the right side actually.

rhs α β x = α

We can only use always in macro form unfortunately.

→ Ty m Ty n α β = K α ~> K β

This is really simple except for the damn type arguments

We could make a little "dumb" inference method.
Fill types or something.

Fill types would be very useful in general.
Fills in placeholders.

→ Ty m Ty n α β = K Ty m α α ~> K Ty n α β

So we just need to copy α into the K's

(K Ty m ~> K Ty n) α = K Ty m α ~> K Ty n α

This is fine for the right hand side.

Rhs = K Ty n
Lhs needs to copy α.

lhs = S (K Ty m) (I Ty m)
lhs α = K Ty m α α

type arguments for S

HMPH. We need α here.

Remember the typing rules for S.
Our stuff gets instantiated.

Syntax sugar for "self":

self α = K α α

S Ty m Ty m

S (K Ty m) (I Ty m)

S Ty m Ty m ( (K Ty m) (I Ty m)

Is it really this hard?

→ Ty m Ty n = _ ~> K Ty n

One cheeky thing we can do

→ = ~>
α ~> β

(α → β) x = α → β

We don't need this extra logic. We just pop when we call an argument.
Really all we need is
α → β = self α ~> K Ty n

Oh this is dank

We can't do → = self ~> K Ty n tho
since self will receive α and β
Also, self isn't even point-free

Can we encode self point-free?

self e := (K (M e) e e)

There are a lot of e's here.
Like I said, we can't instantiate things with just M.

Potentially use S instantiation?
Our S type is all wrong ngl.

We're going to have to redo S type.

New S type:

S α β γ x y z = (M x) (y z)

x : α ~> β ~> γ
y : α ~> β
z : α

x gets instantiated

(α ~> β ~> γ) x y z
This is also wrong.
This turns into
(α x y z ~> β x y z ~> γ x y z)

Can we make a mapping from ∀ x, whatever?


We really need to clean up the ergonomics of ~>.

~> should be smart.
~> shouldn't try to call something that isn't a function.

But this requires type inference.

Really, if we're mirroring CoC, we just need to substitute actual variables.

We can reintroduce placeholders. I like that idea.
This does feel like cheating a bit, but it would clean up literally everything.

New eval rule for ~>.

(_ ~> _) arg = arg ~> arg

(K ~> K) arg = K ~> K

This seems kind of sus, because now we can't really compute in here.

This cleans up a lot though.

New type for K using this:

We can really easily make → now.

Can we make ∀ x, P x?

How do we mimick ∀ as much as possible?

e.g.,
∀ x, B

x ~> B

~> x B  = ∀ x, B

But we need to handle substitution.
Like. We need that.

Let's keep ~> the way it was.

So, how do we make implication?

We can make → a meta-combinator actually.

→ a b = K (M a) a a ~> K (M b) a b

We can make the K type now pretty easily. Ideally without S, but that seems impossible.

There is no reason why we ought not make it with S.
Just complexity.

K : Ty m ~> Ty n ~> → ~> ←

We can duplicate α with →.
But we don't want to duplicate β.

K α β : Ty m ~> Ty n ~> (α → β) ~> (← α β)
K α β : Ty m ~> Ty n ~> α → β → α

Also, we would like to remove ~> in the middle.

Remember, → is just a special case of ~>. We still pass in.
However, this will not type-check for →.
However, we can use ~> in the middle.

K α β : Ty m ~> Ty n ~> → → →
K α β : Ty m ~> Ty n ~> → ~> →

K α : Ty m ~> Ty n ~> → α ~> → α

Using combinators for substitution is mildly clunky.

(self Ty m) this doesn't work when we try to pass in β
(self Ty m) α = Ty m
We need to double-up self.

(self (self Ty m))

We can make a "discard many"

discard Ty m α β

K : Ty m ~.> Ty n ~> ~> ~> <~#

Tools that would help us with writing types with ~>:

We need some way to "reject" specific types.
We know Ty m Ty n. We have that polymorphism. We can leverage that.

(e : t)
(arg₁ : t₂)
(arg₂ : t₃)
discard is just chained K.

discard t t₂ = K t t₂
discard t t₂ t₃ = K ? t₂ (K t t₃)

We can build this pretty easily.

discard t t₂ t₃ = K 

Using discard, we can probably make the type for K.
Is this even necessary?

We only need to reject Ty m. It will be done then.

α can reject β with

K Ty m Ty n

We want α to reject α. That's it, since we're popping after.
This is where self comes in.

self α (x : α) = α
Can we make self'?

| `(⟪ self $e:skmexpr ⟫)              => `(SKM[(K (M $e) $e $e)])

self t = S (K t) (I t)
self t e = ((K t e) e)

expand types

We run into issues again, though, because we haven't established a working type for S.

self t = S t

∘ would be nice as well.

K : (self Ty m) ~> (self Ty n) ~> 

All of these require S.

And S is hard to define without the rest of these. Can we do K without this stuff?

It's possible that the S type might be easier than the others.

What's the goal with S?

S α ? ? K (I α) K = K K K

S α ? ? K (I α) K : M (K K K)

K K K : K → (K → K)

Start by instantiating the type of (x = K) with (z = K)

The shape of x is

t₁ ~> t₂ ~> t₃

Going with our existing rules,

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

Let's say x has that type.

x doesn't get instantiated with anything.
What if we build up incrementally?

y probably takes as an input α. That's fine.

The type arguments are fine. It's just, how do we instantiate γ?

γ = M ((x z) (y z))

Can we reconstruct this^?

Our rule for calls says:

say x : (M K) = (self Ty m) ~> (self Ty n) ~> γ

We can reconstruct γ by

M (x z) = (self Ty n) ~> γ z
M ((x z) (y z)) = γ z (y z)

This is great. But, at the type level,

γ gets x y z, which is not the same

So, really,

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> S (Ty o) γ (α ~> β) γ

This type is ridiculously complicated to produce.

S α β γ (x : α ~> β ~> γ) : 

Back to K type.

K : (self Ty m) ~> (self Ty n) ~> S → 

S → → α = (→ α) (→ α)

Everything is ridiculously complicated to produce bro.

K type should be easier with our meta combinators now.

∘ should be easy to do

(f ∘ g) t x = f (g x)

f ∘ g t = S (K f) g

with types,

f ∘ g t = S t  (K ? ? f) 

K α β : α → β → α
K : →

K : (K Ty m Ty n) ~> ←

K α β : (self α) ~> 

| `(⟪ self $e:skmexpr ⟫)              => `(SKM[(K (M $e) $e $e)])

Point-free I with specified type universe:

"higher" I

We already have normal I.

Let's make the type of K.

We get α inside this body.

K : ∀ (_ : Ty m) (_ : Ty n), 

Can we make self point-free?

We know (α : t), so we can duplicate e.

self' (t : t_higher) (e : t) = t

Um. Thsi is literally just I.

self' = S t_higher ? ? (K t_higher) (I t_higher)

self' e = K t_higher e e

We want to make I require only a type universe.

I α x : α

I α : K (M α) α α

This seems like a common pattern.

I : self Ty m ~> K Ty m ? 

I : → Ty m

I α : Ty m → α

Typechecks.

pop I α : α

I α : K (M α) α α

I α : α → α
I α (x : α) : α




This thing: K (M α) α α

Very important.

We can derive this. Just need to duplicate α

S Ty m (I Ty m) (K ? (K Ty m) (I Ty m)

S Ty m 

Not exactly.

I : Ty m ~> 

K α β : α ~> (← α β)

We need to make sure α preserves (← α β) and doesn't slap α in front of it

K α β x : α x ~> (self β ~> K (M α) β α)

K α β : α → β

∀ x => C = self x ~> always c

K α β : ∀ (_ : Ty m) (_ : Ty n), (self Ty m) ~> (K+ Ty n Ty m Ty n Ty n) ~> (self α) ~> (K+ ? α β) ~> 

-- We have α and β inside ∀
K α β : ∀ (_ : Ty m) (_ : Ty n), S

S α β γ : (self (α ~> β ~> γ)) ~> (self (α ~> β)) ~> (self α) ~> S γ

x : (α ~> β ~> γ)

S α β γ x y z : γ z (y z)

S α β γ x y z : M ((x z) (y z))

S α β γ x y z : (β z (y z) ~> γ z (y z))

S α β γ x y z : γ x y z

S α β γ x y z : M ((x z) (y z)) = (α ~> β ~> γ) z

γ z (y z)

The output type of S should be γ z (y z)

We need to align the final γ with this.

computing type at the term level:
γ z (y z)

computing type at the type level:
γ x y z

We want S γ x y z

Type of S : ∀ (α : Ty m) (β : Ty n) (γ : Ty o), (α ~> β ~> γ) ~> (α ~> β) ~> (α ~> γ z (y z))

We probably don't have to derive the type of S. In fact, this is error prone. It would suffice to define a macro to do this our selves.

∀ (x : t), x - this is dependent, we need to handle this. This would just be ~> (self t)
What abbout the case where:
∀ (x : t), e₁ e₂? We can use the S transformation rule here.
∀ (x : t), S t ? ? e₁ e₂

We can literally just do ∀ (x : t), S t (M e₁) (M e₂) e₁ e₂

We can do this without the S transformation though.

Most of our types just include ~>.

For example,

K : ∀ (α : Ty m) (β : Ty n), α → (β → α)

For this type, we do need to copy α

We can do this with ~>

α → (β → α) = K Ty m Ty n ~> <~#
K Ty m Ty n α β = α
K+ Ty m Ty n α α β x = α
∀ (_ : Ty m) (_ : Ty n), 

∀ (α : t) (α : x), x

Case of handling a variable in a binder

α is copied in K type. HOWEVER, since we already know α matches, we can use M to derive the final type.

We can probably use the same trick in S?

K : ∀ (α : Ty m) (β : Ty n), K
We don't need to copy α now.

If we add the I combinator, this would be alright.
K : ∀ (α : Ty m ) (β : Ty n), K+ Ty m Ty n α α

 Fun fact: y doesn't necessarily have to be well-typed. It doesn't really go anywhere. We just need the type to line up.

α does need to line up though.

K : ∀ (α : Ty m) (β : Ty n), α → M → M
K : ∀ (α : Ty m) (β : Ty n), ← (M ~> M) α

The thing is, though, we can't use M in that position for β, since we don't know it's well-typed. We don't know it terminates.
We need to have it all explicit, really.
K : ∀ (α : Ty m) (β : Ty n), ~>
α ~> α

Uhhh remember, ~> copies to functions, too

(K ~> K) α = K α ~> K α
I ~> K

(I ~> K) α = I α ~> K α

K α β : α → β → α

or

K α β : α → K (M β) β β ~> M

K : ∀ (α : Ty m) (β : Ty n), α → β → α

K : ∀ (α : ?) (β : ?), 

I mean, we don't really need to know that y is of type β

We probably don't even need Ty m

K : ∀ (α : Ty m), α → M → α

S ? ? ? → ←

K : S ? ? ? ← ← 

K α : α → (← α)

Note that we can still copy in →, since it's syntax sugar for ~>. We just reject in the input.

K α β : α → (β → α)

α → β meta combinator that evalutes to:

(self α) ~> (λ _ : M α) => β

K : ∀ (α : Ty m) (β : Ty n), α → β → α

Can we translate this?

We can add a "pop" macro.

K : ∀ (α : Ty m) (β : Ty n), S ? ? Ty m → ←

S → ← α = → α (← α)

We can translate λ (x : t) => e₁ e₂ now



K : ∀ (α : Ty m) (β : Ty n), S ? ? ? → (@(→) 

We can probably do some kind of type inference in our macros.

S α β γ : ∀ (_ : (α ~> β ~> γ)) (_ : (α ~> β )) (_ : α) ~> S M

S  ? Ty m → ←

What's the type of → α?

Ty n → (max Ty m Ty n).succ

S  Ty m ? (Ty n → Ty (max Ty m Ty n).succ) → ←

What's the type of → α?

subst with α, @I t α 

K in type?



So we can actually do the S transformation here.

But we kind of can't, because we don't know the type of →.
We also don't know the type of ~>.

∀ (α : Ty m) (β : Ty n), α → β = @∀ (α : Ty m) (β : Ty n), 

EXCEPT, we can't pop from M e₁

type of K now

K : ∀ (_ : 

∀ (_ : t), body - this is handled already, BUT we need to make the body K whatever.
Here, it's K ? t body

Let's say

x : α ~> β ~> γ
y : α ~> β
z : α

M (x z) (y z)

= γ z (y z)

Fantastic

So, we can change the type of S to align with this.

Also,

(α ~> β ~> γ) gets instantiated with x.

S+ expansion

S f g x = (f x)(g x)

S (S f g) h

Feeds to multiple.

Feed to multiple or feed multiple in?

S (K S) (S f g) x
= S ((f x)(g x))

S (K S) (S (K S) S( f g)) x

= S (S (S f g))


* Hand-derived K type

~> rule: why do we need to always propagate?

K : K (Ty m.succ) (Ty m) (Ty m) ~> K (Ty n → Ty n.succ) (Ty m) (K (Ty n.succ) (Ty n) (Ty n)) ~> thing

S ← → α = ← α (→ α)
S → → α β = → α (→ α)

S (K (→ α)) (← α) β = α → (β → α)
S (S (K (S K)) ←) → α = K (← α) (→ α)

Can we modify the rules for ~> at all to make this easier?

(a ~> b) e = e a ~> e b is already intuitively sus

There should be no eval rule for this at all, really.

K : <~# ~>

K : Ty m → Ty n → 

Any other combinators we can make?

What is the combinator with type:

K : <~# ~>

K : ~> Ty m (~> Ty n)

What about this eval rule:

This is dumb though because we're baking in logic into the combinator.

~> e₁ e₂ arg = ~> e₁ (e₂ arg)

K α : α ~> (~>)

e : ~> <~#

What is our typing rule for function calls?

apply argument to type of left-hand side.

All we need is something we can interpret as a typing.
We want to unify all types under ~>
most natural approach: function type decides what to do with the argument

~> is really just a marker

It deosn't do anything.

So what is the type of ~>?

but we want ~> to work with any expr, we don't want to have universes
~> : ~> <~#

~> α : <~# ~> α
~> α β : 

Is it possible to remove sorts?

K α β : (M α) ~> (M β) ~> α ~> β ~> α

This is stupid.

Theoretically, we can use a search tree for the type of K. This is kind of the same as doing translation though.

* Eta-expanded K type, potential hints towards point-free?

~> doesn't do any logic itself.

We want to discard x and produce α ~> 

K α β : K (α ~> (K β ~> α))

This expression requires copying α

Same eval rule for M of arrow.
M t_in ~> t_out = M t_out


K α β x : α ~> (K (β ~> α))
K α β x y : β ~> α
K α β x y : α

There's a lot of filling in to do here.

First off, have to copy α

K : S (K (~> Ty m)) (S ~> <~#))

K : S (K (~> Ty m)) (S (K (S (K ~> Ty n)) (S ~> <~#)))

K α : Ty m ~> (α ~> (<~# α))
K α : (α ~> (<~# α))

K α β : K (α ~> (K β ~> α))

K : S (K (~> Ty m)) (S (K (S (K ~> Ty n)) (S ~> <~#)))
K α : Ty m ~> ((S (K ~> Ty n) (α ~> (<~# α)))
K α β : Ty n ~> ((α ~> (<~# α))) β)

K : S (K (~> Ty m)) (S (K (S (K ~> Ty n)) (S (S (K S) (S (K K) ->)) <-)))
K α : Ty m ~> (S (K ~> Ty n)) ((S (K S) (S (K K) ->) α)) (<- α)))
K α : Ty m ~> (S (K ~> Ty n)) ((S (K (-> α)) (<- α)))
K α β : Ty n ~> (-> α) (<- α β))
K α β : α -> (β -> α)

K α β x y : α

With M:

We can express the type of arrows by assuming the existence of a "canonical type". Also, beta-equivalent types should be fine.

(α → β → γ) → (α → β) → (α → γ)

(x : S (K (~> α)) (S (S (K (K ~>)) β) γ))
(x : S (K (~> α)) (S (S (K S) (S (K K) (S (K ~>) β))) γ))
M (x z) : α ~> (S (K (~> (β z)) (γ z))
M (x z (y z)) : (~> (β z)) (γ z (y z))
M (x z (y z)) : (γ z (y z))

(y : S (K (~> α)) β)
y z : α ~> (β z)
z : α

S α β γ (x : S (K (~> α)) (S (S (K (K ~>)) β) γ)) (y : S (K (~> α)) β) (z : α) : M (x z (y z))

* Type universes

Might be possible to completely remove sorts.
In K α, α : Type something

But it's not clear that anything has this type, since all types are just K or S expressions.

We could just say α : (M α). This is fine. We can probably remove sorts, then.

What's the type of M?



K : S (S (K ~>) M) (S (K (S (S (K ~>) M)) (S (S (K S) (S (K K) ->)) <-)))
K α : (M α) ~> (S (S (K ~>) M) ((S (S (K S) (S (K K) ->)) <-))) α)
K α : (M α) ~> (S (S (K ~>) M) (S (K (-> α))) (<- α)
K α β: (M β) ~> α -> (β -> α)
K α β x : (β → α)
K α β x y : α

(α : M α)

* M as quotation

M e is obviously a type.
M is polymorphic, we don't know the type of e.
We can potentially treat M as a "quotation" / lift to type operator.
M marks something as a type.

K : whatever

This is bad, since whatever is some SK expression. We would like to distinguish these.

We can say K : M whatever

But we don't want this to explode.
Theoretically, we don't need an evaluation rule for M.

M is quotation.
M has no evaluation rule.
We don't normalize.
We don't need reflection.

In the type of K, we still need to know the type of \alpha, though, since we want to copy it.
for all e, M e : Type.

So we don't even need type universe

M e : Type, but this isn't saying e is necessarily well-typed.

K : 

We can fill in the types for K now.

Type of ~>?

~> : M (~>)
~> α β : M (α ~> β)

K : M (S (S (K S) (S (K K) →) ←)
K α : M (S (K (→ α) (← α))
K α β : M (S (K (→ α) (← α))
K α β : M (→ α (← α β))

→ : M (Type → Type → Type)

α → β := M (α → β)

Type → Type := M (Type → Type)
Type → Type : Type

→ α : Type → Type

→ : Type → Type → Type

K : M (S Type ? ? (S Type ? ? (K ? Type (S Type ? ?)) (S Type (Type → Type → Type) Type (K (Type → Type → Type) Type (K (Type → Type) Type)) →) ←)

S type, eta expanded

(x : S (K (~> α)) (S (S (K (K ~>)) β) γ))
(x : S (K (~> α)) (S (S (K S) (S (K K) (S (K ~>) β))) γ))
M (x z) : α ~> (S (K (~> (β z)) (γ z))
M (x z (y z)) : (~> (β z)) (γ z (y z))
M (x z (y z)) : (γ z (y z))

(y : S (K (~> α)) β)
y z : α ~> (β z)
z : α

* Can we avoid using S in K type?

Defering to S in the type of K introduces a lot of complexity.

It may be necessary.
But in order to use S in the type of K, we need to write out the type for S, which is complicated.

For now, we can only deal with eta-expanded K (for testing purposes).

Even with eta-expanded S, the type is still complex.

Also note that with our rule, type-checking K requires type-checking K.
The difference is that we're dealing with simple types.
In theory, this shouldn't explode forever.

Evaluation within quotation should be impossible.
We shouldn't normalize within M.

We can pattern match from M, but we can't normalize.

So, whatever the type of K is is kind of useless.
We need to expand it at runtime.

Are ~> and -> the same?

Since 

~> α β : M (α ~> β)
α → β := M (α → β)

M (α ~> β) arg is undefined.

We don't want to normalize in a type, ever.

So how do we instantiate dependent types?

K α is not well-typed.
K α β is well-typed.

For function application, it seems like some normalization is necessary.

Let's consider simply-typed for now.

Do we even need →?

Polymorphic S:

S α β γ : (α → β → γ) → (α → β) → α → γ

This is super easy.

Dependent S:

S (α : Type) (β : 0α → Type) (x : α → (β z) → (γ z (y z))) (y : α → (β z) → Type) (z : α) : γ z (y z)


* Quotation separation

- No term-level eval rule for quotation. M e is inert
- We're allowed to "pattern match" on it via definitional equality in type position.

* Full dependent K using quotation

K : S (S (K ~>) M) (S (K (S (S (K ~>) M)) (S (S (K S) (S (K K) ~>)) <~#)))

* Dependent S

S : ∀ (α : Type) β γ (x : M (S α ? ? (K (α ~>)) (S ? ? ? (S (K ~>) β) γ) (y : M (S α ? ? (K (α ~>)) β)) (z : α), ((S α ? ? (K (α ~>)) (S ? ? ? (S (K ~>) β) γ)) z (y z)
