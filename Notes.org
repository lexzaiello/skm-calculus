* Sk plan

Limitations of old approaches:
- Can't extract a "truth value" from M
  - Can't distinguish well-typed M from ill-typed
  - *New approach: constructive proof - you cannot produce M e t if e is not well-typed, since M e t will not type-check otherwise*
- Typings of K and S are complex
- Typings of K and S are the same as K and S
- M e t is the term representing "e is well-typed with type t"

M (M e) = M e t if e is well-typed

* Arrow abstraction / interpretation

- The only "base" types we have are M K, M S, and M M
- These don't actually reduce to anything
- We can interpret M (K \alpha \beta) as \alpha \rightarrow \alpha \rightarrow \beta
- We can interpret S similarly
- What is K \alpha, though?
  - We can just say this is SKM[((M K) \alpha)]
- But how do we unify arrows and just regular shit?
  - Do we even have to?
- How do we handle the beta-equivalent case?

* Arrow combinator

This is the holy grail. Adding a first-class arrow combinator.

* Arrow combinator functionality

We would like to have evaluation rules for ~> that behave similarly to \forall. We can do this if we derive the ~> expression via evaluation rules
We can do this the pure combinator way now, but I don't like this.
Point-free M K is nice.

* Fully dependent S and K, no partial M

K : #~>

K : #~>

K α : #~>

K α β : α ~> β
K α β x : α ~> 

K α β : #~> α β

K : S #~> #~>

K : #~>

K α : #~> α

K α : #~> α (#~> α)

K α β : #~> α (α β)

New S type just dropped?
There's this nice elimination we can do for this case
S : (#~> #~>) #~>
S α : α ~> (#~> #~>)
S α β : β ~> #~>
S α β γ : 

This is literally substitution.
We can just change the evaluation rule for ~>
such that ~> doens't pop the body. It just passes the argument through the type.

Wait ayo. We only pop the body of the ~> when a function call happens. When there's an eval step.

(t_in ~> t_out) arg = t_in ~> (t_out arg)

So S : (#~> #~>) #~>

K : #~> #~>
K α : (#~> #~>) α
K \alpha : #~> ~> \alpha
K \alpha \beta : #~> ~> \alpha \beta

Now when we evaluate K \alpha \beta x, lhs type becomes
~> \alpha \beta

Well, technically K \alpha \beta x is not an "eval step", whatever that means.

(t_in ~> t_out) arg = = t_in ~> (t_out arg)
(t_out <~ t_in) arg = = t_in ~> (t_out arg)

I think this is fine. But when do we pop to just t_out arg?
Intuitively, whenever we have a reduction.

*OR, we pop when there are no #~> left to fill.*
^^ I like this one.

This should actually be defined the same for K and S.

K : Ty 0 ~> Ty 0 ~> (S #~> #~>)
K \alpha : Ty 0 ~> Ty 0 ~> (\alpha ~> ((#~> \alpha))
K \alpha \beta : Ty 0 ~> Ty 0 ~> (\alpha ~> (\alpha ~> \beta))
K \alpha \beta x : Ty 0 ~> (\alpha ~> (\alpha ~> \beta))

Why can't we keep popping per-arg?

K : Ty 0 ~> Ty 0 ~> (S #~> #~>)
K \alpha : Ty 0 ~> S #~> #~> \alpha
K \alpha \beta : \alpha ~> (\alpha ~> \beta)

There's some incongruency here causing this.
But popping per-arg is fine.

We would just like to flip ~> in this type.
We could theoretically just add a <~ combinator.
Or we can just rework this expression somehow.

With <~, it's really clean though.

K : Ty 0 ~> Ty 0 ~> (S #~> <~#)
K \alpha : Ty 0 ~> \alpha ~> (<~# \alpha)
K \alpha \beta : \alpha ~> (\beta ~> \alpha)

We need to actually return \alpha though and discard our argument, since when we add x as an argument, it gets fed in.
K \alpha \beta x : \alpha ~> (\beta ~> \alpha x)

This is fine, I think.
For ergonomics we may want to remove the weird K thing we have to do at the end.

So the eval rule for ~> is
(\alpha ~> \beta) x = \alpha ~> (\beta x)

Except we don't know when \beta is a normal value.
So we do actually need K in the type of K.

K \alpha : Ty 0 ~> \alpha ~> (<~# (K \alpha)))
K : Ty 0 ~> Ty 0 ~> (S #~> (S <~# 

K \alpha : Ty 0 ~> \alpha ~> (<~# \alpha)

Mwah. Chef's kiss.

K : S #~> #~>
K \alpha : \alpha ~> (#~> \alpha)
K \alpha \beta : 

Why don't we just pop the types eagerly?
Like whenever you supply an argument, you pop the type?
This makes things a lot more complicated.
Perhaps have both?

ALTHOUGH. We could just not pop anything at all, but define the type of M recursively so that it does the popping then.

Ok so what about S?
We can do this nice type instantiation now with our arguments.

The question is, do we choose:
S (\alpha \beta \gamma : Type) : (\alpha \rightarrow \beta \rightarrow \gamma) \rightarrow (\alpha \rightarrow \beta) \rightarrow (\alpha \rightarrow \gamma)

or

S (\alpha \beta \gamma : Type) : \alpha \rightarrow \beta \rightarrow \gamma


This is lowkey ass because we have ZERO type information about the next step of evaluation.
But if we capture that somehow...

S (\alpha \beta \gamma : Type) : 

ALthough now that I think about it, now that we have arrows for our K and S, we don't need to split this up. We can just use the canonical one.

We need to control the order these are filled in.
We need to copy \alpha in one step.

Now this one is unironically nontrivial. Lol.

Fun fact though, \alpha ~> \beta ~> (\alpha ~> \gamma) = S (#~> (#~> \beta)) (<~# \gamma) \alpha = ((\alpha ~> (#~> \beta))) (\alpha ~> \gamma)
Fun fact though, \alpha ~> \beta ~> (\alpha ~> \gamma) = S (#~> \beta) (<~# \gamma) \alpha = (\alpha ~> \beta) (\alpha ~> \gamma)
Perhaps we can somehow join all these things up with ~> at the end.

So, for example, S (\alpha ~> \beta ~> \gamma) (\alpha ~> \beta) <~# (\alpha ~> \gamma) = <~# (\alpha ~> \beta ~> \gamma) (<~# (\alpha ~> \beta))

S \alpha : Ty 0 ~> Ty 0 ~> 

S : Ty 0 ~> Ty 0 ~> Ty 0 ~> 

S : Ty ~> Ty ~> Ty ~> S Ty Ty Ty 
S \alpha : Ty ~> Ty ~> S Ty Ty Ty \alpha
S \alpha \beta : Ty ~> S Ty Ty Ty \alpha \beta
S \alpha \beta \gamma : (\alpha \gamma) (\beta \gamma)

S : Ty ~> Ty ~> Ty ~> S (S #~> #~>) #~>
S \alpha : Ty ~> Ty ~> ((S #~> #~>) \alpha) (#~> \alpha)
S \alpha : Ty ~> Ty ~> (\alpha ~> (#~> \alpha)) (#~> \alpha)

We can potentially build the types incrementally.
So instead of copying \alpha into the fully type at once, we build it out in each step.
We really just need to know the "next input type." Not ALL the input types.

S \alpha \beta \gamma : (\alpha ~> \beta ~> \gamma) ~> 
X type has to match
S \alpha \beta \gamma x : #~> x
We need to "re-extract \alpha and \beta" from x. This is possible.
If we call x with some argument, the argument will be passed as a parameter to \gamma.

Ok, another strategy. We can build the type inside out.
We can build \alpha ~> \beta ~> \gamma out of y and (z : \alpha).
y : \alpha ~> \beta and z : \alpha 
So, theoretically, (M y) (<~# \gamma) = \alpha ~> \beta ~> \gamma

However, this is not predictive.
There is no specific reason why we can't have the types of S in reverse:
S : \alpha \beta \gamma, \alpha ~> (\alpha ~> \beta) ~> (\alpha ~> \beta ~> \gamma)
S \alpha \beta \gamma z y x = (x z) (y z)
However we're being extremely cheeky here, sine we haven't even constructed the types from the input type arguments.
We need to predict the ENTIRE type via the type arguments, then decompose.
We can add a new combinator for this if we want to. But I would prefer not to.

HOWEVER, like I said, we can build the type one argument at a time.
We just need to construct \alpha ~> \beta ~> \gamma first.

S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma) = ((#~> \alpha) (#~> \beta \gamma) = #~> #~>
S : <~# <~#
S \alpha = <~# <~# \alpha = \alpha #~> <#~
S \alpha \beta = \alpha #~> (<#~ \beta)
S \alpha \beta \gamma = \alpha ~> (\beta ~> \gamma)

So we know how to construt (\alpha ~> (\beta ~> \gamma)) now.
Getting (\alpha ~> \beta) is just popping the deepest nested \gamma, but we don't have an operation for that.

Creating \alpha ~> (\beta ~> \gamma) is pretty simple though. It's just <~# <~#.
So, logically, we can just copy \alpha and \beta when we do this.

S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)

Now, remember, we will pass x in, and it will be bubbled into \gamma.

"Return" within a ~>:

- When we're "finished" building a type, we need to "return" the value with K so that further type arguments don't get bubbled down.
For example, the type of K:

#+BEGIN_SRC lean
K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) <~#)
#+END_SRC

For \alpha \beta, this produces:

K \alpha \beta : (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) <~#) \alpha \beta
K \alpha \beta : (#~> \alpha) (<~# \alpha) \beta = \alpha ~> (<~# \alpha) \beta = \alpha ~> (\beta ~> \alpha)

For \alpha \beta x y, this produces:

K \alpha \beta x y : \alpha x y

This is not really what we wanted.
However, we can fix it in our (#~> \alpha) (<~# \alpha). Just replace the second one with (<~# (K \alpha))

However, we could potentially change the evaluation rules to handle this. Obviously, we should bubble if:

(t_in ~> t_out) arg

But theoretically, the output type might want to do something with the argument anyway. So we need to bring back !~>.

K \alpha \beta : (#~> \alpha) (<~# (K \alpha)) \beta
K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) (S (K <~#)) K))
K \alpha : Ty n ~> (\alpha ~> (<~# (K \alpha)))
K \alpha \beta :  (\alpha ~> (\beta ~> (K \alpha)))
K \alpha \beta x : \beta ~> (K \alpha x)
K \alpha \beta x y : (K \alpha x) y

K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) (S (K <~#)) (S (K K) K)))

K \alpha : Ty n ~> (\alpha ~> ((S (K <~#)) (S (K K) K)) \alpha))
K \alpha : Ty n ~> (\alpha ~> (<~# (K (K \alpha))))
K \alpha \beta : \alpha ~> (\beta ~> (K (K \alpha)))
K \alpha \beta x : \beta ~> K \alpha
K \alpha \beta x y : K \alpha y = \alpha

We need another K. 

** Dependent S Typing

We know how to produce (\alpha ~> \beta ~> \gamma):

#+BEGIN_SRC lean
S : Type m ~> Type n ~> Type o ~> (<~# <~#)
S \alpha : Type n ~> Type o ~> (#~> #~>) \alpha
S \alpha : Type n ~> Type o ~> \alpha ~> (#~>)
S \alpha \beta : Type o ~> \alpha ~> (#~> \beta)
S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)
#+END_SRC

We can produce \alpha ~> (\beta ~> \gamma) easily.
We can also produce \alpha ~> \beta easily. But, producing all 3 is very difficult.
A possible strategy for (\alpha ~> \beta) ~> (\alpha ~> \gamma):

Note that \alpha is duplicated, while \beta and \gamma aren't.

This is in essence: S (<~ \beta) (<~ \gamma) \alpha = (\alpha ~> \beta) (\alpha ~> \gamma)

But what about the ~> in between? This would seem complicated, but we can construct (\alpha ~> \beta) ~> (\alpha ~> \gamma) by #~> (\alpha ~> \beta) ~> (\alpha ~> \gamma).

#+BEGIN_SRC
So, (S (K ~>) (S (<~ \beta) (<~ \gamma))) α = (~>)
#+END_SRC

However, this does not have the parenthesization we want.


S (<~ \beta) (<~ \gamma) \alpha

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

The question is, do we even want this? We would like to be able to instantiate dependent types in shit like

(x z) (y z)

This typing appears to be just polymorphic.

We want:

S α β γ x y z : (((M x) z) (y z))

But we want to restrict inputs in some way.
S α β : (α ~> x_out) ~> (α ~> y_out) ~> S α 
S :  Ty 0 ~> Ty 0 ~> Ty 0 ~> (S Ty 0 Ty 0 Ty0)
S α β γ : (α γ) (β γ)

Really what we want is:
S α β γ x y z : (((M x) z) (y z))

This is not hard to achieve, but we need to restrict our inputs such that (x : α ~> ((M y) z))

But, we can't instantiate y and z, since we don't know what they are yet.

There isn't really a reason why we can't upgrade the type of S like such:

We can only really restrict types predictively.
We can't post-hoc restrict a type further. Or can we?
Really, I would like as minimal arguments to the function as possible.

What we want is:

S α β γ x y z : (α z) (y z)

Imagine they're popped off:

Ayo we're calling α here. Wtf.
This is possible if α is an arrow expression, because then it has type Ty.

- α z creates a new type
- y z creates a new term
- we can know the type of this already
- α z new type should expect ((M y) z) as an input
- So it's not clear what the type of x is immediately, since it expects y z as an input
- (y z) could be used to instantiate the type

- We can make assertions about x_out, though
- We may not be able to assert that the full type of x is α ~> β ~> γ,
but we can say that it expects α as an input, produces some output,

We can do type inference for S really easy:
M (S _ _ _ x y z) = ((M x) z) (y z)

Looking at this type, we can see x : M x, M x = α
We can see that α : γ 

S α β γ x y z : (α  ~> x_out) ~> (α ~> y_out) ~> α ~> (α z) (y z)

Also, another thing. Our typing judgment for α ~> β is kind of funky.
We really ought to separate the typing for ~> (pi) and →.
α → β is Ty whatever
while α ~> β is actually (M β). TODO

So, in ((M x) z) (y z),
(M x : α ~> 
(y : α ~> y_out)
(z : α)
(M x) : α ~> x_out
(x_out : (y_out α)

Is polymoprhic S actually polymorphic?
f
S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

There doesn't appear to be any dependency on terms in these types. Ngl.
Is this equivalent to ((M x) z) (y z)?

S α β γ x y z : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ ~> ((M x) z) (y z)

y : α ~> β
x : α ~> (β α) ~> γ
z : α

S α β γ y_out : (α ~> (y_out α) ~> γ α)

"Polymorphic" S actually is dependent, since it's not actually polymorphic. ~> does all the heavy lifting.

S α β γ :  (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ
S α β γ x y z : ((M x) z) (y z)
S α β γ x y z : ((α ~> β ~> γ) z) (y z)
S α β γ x y z : (γ z) (y z)

On to actually making the S type.

**** S is dependent, but how do we construct its type?

We can construct a type of the form α ~> β ~> γ pretty easily.

S : Type m ~> Type n ~> Type o ~> (<~# <~#)
S \alpha : Type n ~> Type o ~> (#~> #~>) \alpha
S \alpha : Type n ~> Type o ~> \alpha ~> (#~>)
S \alpha \beta : Type o ~> \alpha ~> (#~> \beta)
S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)

we'll say

def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

This makes α ~> (β ~> γ)

We can also make α ~> β. This is extremely simple. I'll use the same order of arguments, α β γ

def mk_ty := Type m ~> Type n ~> Type o ~> ~> ~>

mk_ty α β γ = ~> ~> α β γ = (~> ~> α) β γ = → ~> (α β) γ = (α β)

def mk_ty := Type m ~> Type n ~> Type o ~> ~> ~>

First with just α and β

def mk_ty_simple := Type m ~> Type n ~> ~>
mk_tysimple α β = α ~> β

Now we just discard γ.
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

^ Done.

mk_ty α β γ = (<~# K α β γ) = (α ~> K) β γ = (α ~> (K β)) γ = (α ~> β)


So, now we can construct (α ~> (β ~> γ)) and (α ~> β)

The rest of the type is literally just copiny γ and α.

Or, if we want, we can make a similar method to make this part of the call.

If we had something to "flip" K, that would be nice.
Or, alternatively, we can use →.
mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

^^ This works.

mk_ty_z α β γ = (~> →) α β γ = (→ ~> α) β γ = ~> α γ = α ~> γ

Ideally, we can compose these functions together to make the segments of the type.

We just need to duplicate α β γ each into each.
Let's make a α β γ "map" - this is just the functions we made


Catalogue: mk_t_x - (α ~> β ~> γ), mk_ty - (α ~> β), mk_tz - (α ~> γ)
Each of these accept α β γ as inputs.

To copy α, for example:
S mk_tx mk_ty α = (mk_tx α) (mk_ty α)
This is not particularly useful.

Simple algorithm: S already takes α β γ. We can use a fixpoint to duplicate in a way.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx
S α β γ = (α ~> β ~> γ) ~> 

Oh this is actually super simple.

Remember that (t_in ~> t_out) arg just pops one t_in, produces t_out arg
But we shouldn't just recurse like this forever.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx ~> mk_ty ~> mk_tz
S α : ~> Ty m (~> Ty n (~> Ty o (~> mk_tx (~> mk_ty mk_tz)

Evaluation here, α pops off the Ty m, we get (~> Ty n (~> Ty o (~> mk_tx (~> mk_ty mk_tz) α.
We don't want this to recurse forever. Our eval rule for (t_in ~> t_out) arg is broken. Really, it should be:
(t_in ~> t_out) arg = (t_in ~> t_out arg)
However, we should be able to use ((((M K) α β) x) y) and receive α

Quick recap of K type:

#+BEGIN_SRC lean
K : SKM[Ty m ~> Ty n ~> (((((S m.succ n.succ m (M (~>))) (M (<~))) Ty m) (~>)) (←))]
#+END_SRC

Same shit here, eval_once will work. K α : (Ty n ~> ...) α, but if we continue eval'ing this, we will pop ALL of the arguments.
We only want to pop once.

What happens if we fully evaluate K α?

#+BEGIN_SRC lean
K α : (((((S m.succ n.succ m (M (~>))) (M (<~))) Ty m) (~>)) (←)) α
K α : (~> α) (← α)
#+END_SRC

We can just insert Ty n deeper in here. We want Ty n ~> α (← α), such that
K α β : (α → α) α - this is wrong.

We could actually change the eval rues. We can just extend (t_in ~> t_out) arg := t_out arg to

t₁ ~> (t₂ ~> t₃) arg := (t₂ ~> (t₃ arg))
This is fine, ish, since now we're only ever obliviating one type.
Say we have t₁ ~> (t₂ ~> (t₃ ~> t₄)))), though

(t₁ ~> (t₂ ~> (t₃ ~> t₄))))) arg = (t₂ ~> ((t₃ ~> t₄) arg))

Ok, eval rules are fixed.

We could just algorithmically insert arg.

So, now, back to copying α β γ into our type constructors.

S (mk_tx mk_ty α = 

S : Ty m ~> Ty n ~> Ty o ~> 

S : (α ~> β ~> γ) ~> (α ~> β) ~> (α ~> γ)
S : Ty m ~> Ty n ~> Ty o ~> S (S mk_tx mk_ty) mk_tz

(S (S mk_tx mk_ty) mk_tz)  α β = (mk_tx α) (mk_ty α) (mk_tz α)

How do we do multiple variables tho...
S (S (mk_tx α) (mk_ty α)) (mk_tz α) β ..
this is the pattern.

How do we produce it?

(S (S (S mk_tx mk_ty)) mk_tz) α β = ((S (S mk_tx mk_ty)) α) (mk_tz α) = (S mk_tx mk_ty) (mk_tz α) (α (mk_tz α))

((S (S mk_t_x mk_t_y) mk_t_z) α) = ((S mk_t_x mk_t_y) α) (mk_t\z α) = ((mk_tx α) (mk_ty α)) (mk_t\z α)

S α : Ty n ~> Ty o ~> S (mk_tx α) (mk_ty α)
S α β : Ty o ~> S ((mk_tx α) β) ((mk_ty α) β)
S α β γ : (((mk_tx α) β) γ) (((mk_ty α) β) γ))

This is promising.



Other technique: we don't have to bbuild the type all at once. Do it in layers.

Or, hypothetically, we could extend our mk_twhatever with the ability to chain them together?

S α β γ : mk_t_x α β γ 

S (S (mk_t_x α β γ) (mk_t_y α β γ)) (mk_t_z α β γ) α β γ = (S (mk_t_x α β γ) (mk_t_y α β γ)) α (mk_t_z α β γ) α β γ
= (mk_t_x α) (mk_t_y α) (mk_t_z α) β γ

S (S (mk_t_x mk_t_y) (mk_t_z) α β γ

S (S mk_t_x mk_t_y) mk_t_z α β γ =
  (S mk_t_x mk_t_y) α (mk_tz α) β γ
= (mk_tx α) (mk_ty α) (mk_tz α) β γ

S (

Other approach, type by type

We can copy α here. We need to copy it three times.

S : Ty m ~> S (<~# <~# Ty n) (S ~> ~>)
S : Ty m ~> S (K (~> Ty n)) (S mk_tx mk_ty)
S α : S (K (~> Ty n)) (S mk_tx mk_ty) α = (~> Ty n) ((mk_tx α) (mk_ty α))

                                                                 ^ here
We want to add another layer for copying β in. We just need to insert an S

S : Ty m ~> S (K (~> Ty n)) (S (S (K S) mk_tx) mk_ty)
S α : Ty n ~> ((S (S (K S) mk_tx) mk_ty) α) = Ty n ~> ((S (mk_tx α) (mk_ty α)))
S α β = ((m_tx α) β) ((m_ty α) β)

Manually making this S type is going to be a fucking herculean task.

We already know we can make the type of x (α ~> β ~> γ).

Are there any other smart encodings we can come up with?

Really, the most important type is x. We just have to show that the rest are well-typed.

Once we have x as an input, we can test y and z using x,
since x has the type (α ~> β ~> γ).
We can probably even form (α ~> β) from it, since α ~> β ~> γ = (~> (~> (~> α) β) γ)
If we can inject K, we can do it.


S : Ty m ~> Ty n ~> Ty o ~> mk_tx ~> 

S : Ty m ~> S (K (~> Ty n)) (S (S (S (K (~> Ty o)) S) mk_tx) mk_ty)
S α : S (K (~> Ty n)) (S (S (S (K (~> Ty n)) S) mk_tx) mk_ty) α
    = (Ty n ~> (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α))

S α β : (Ty n ~> (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α)) β
    = (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α) β
    = (S (S (K (~> Ty n)) S) mk_ty (mk_tx mk_ty) α β
    = ((S (K (~> Ty n)) mk_ty) (S mk_ty) (mk_tx mk_ty) α β
    = ((K (~> Ty n) (S mk_ty)) (mk_ty (S mk_ty)) (mk_tx mk_ty) α β
    = ((mk_ty (S mk_ty)) (mk_tx mk_ty)) α β

S with 3 fanouts:
S : Ty m ~> S (K (~> Ty n)) (S (S (S (K S) mk_tx) mk_ty) mk_tz)
S α : Ty n ~> ((S (S (S (K S) mk_tx) mk_ty) mk_tz) α)
S α β : (((S (S (S (K S) mk_tx) mk_ty) mk_tz) α) β)
        = ((S (S (K S) mk_tx) mk_ty) α) (mk_tz α) β
        = ((S (K S) mk_tx) α) (mk_ty α) (mk_tz α) β
        = ((K S) α) (mk_tx α) (mk_ty α) (mk_tz α) β
        = S (mk_tx α) (mk_ty α) (mk_tz α) β
        
        

S α : S mk_tx mk_ty α = (mk_tx α) (mk_ty α)
For S α β, we just do S (mk_tx α) (mk_ty α) β instead
Then same for S α β γ

I really feel like we ought to decouple substitution from popping.
If we just do (α ~> β) arg, we should just get (α ~> (β arg)),
but if we do M of a call, then we trigger popping.

Well, we're in a type, so we should trigger popping.
There's also another possibility which is that we introduce yet another arrow.
But I don't like this.

S α : (Ty n ~> α (α ~> (~> α))) 



S : Ty m ~> Ty n ~> Ty o ~> S 

We can chain these together by making mk_tx copy its arguments to a callee (golly gee this is getting really complicated though).

* When to trigger "substitution" vs popping

- (α ~> β) arg should be treated as substitution
- ((M e) arg) where (e : α ~> β) should invoke "popping"

This is a nice barrier between head reduction and reduction within the expression.

For example, with the type of K:

#+BEGIN_SRC lean
K α : Ty n ~> (((((S _m.succ n.succ _m (M (~>))) (M (<~))) Ty _m) (~>)) (←)) α
K α β : (((((S _m.succ n.succ _m (M (~>))) (M (<~))) Ty _m) (~>)) (←)) α β
K α β : (~> α) (← α) β = (α ~> (← α)) β = β → α
#+END_SRC

This would also simplify the typing of S significantly, since we would be able to manipuatel the full type of =S= in multiple passes without losing structure. Note, however, that items will still be popped in that case, since any arguments will necessarily invoke popping.

We gotta fix the K type, since it's discarding one of the α.

S α β γ : (α ~> β ~> γ) ~> whatever

This "no-pop feature" seems really important. Would make the typing for K really really clean.

Would be what I need to make this work.

#+BEGIN_SRC lean
K : Ty n ~> Ty m ~> S ~> <~
#+END_SRC

The question is, where do we pop if not in eval for (t_in ~> t_out) arg?
Most obvious candidate: evaluation, though this is not necessarily true.
Just type-checking a function call will probably invoke pop.
So, generalize to all function calls.

Essentially, (((M K) α β) x y) just does substitution, but (M (K α β x y)) does the actual popping.

So, the rule is M (lhs rhs), pop lhs's type.

The question is what to do about →?
I think the same should hold.

I really don't want to make this retarded like "pop" combinator. 
Is there a way to represent it?

Essentially taking an expression of the form α ~> β and turning it into β?
This is represented as ((~> α) β).
We don't necessarily need a pop combinator. If our left-hand-side type eval's to a ~>, we just pop it.

Popping is separate from substitution now.

Now, we can use this really nice K typing:

#+BEGIN_SRC lean
K : (Ty n ~> Ty m ~> S ~> <~)
K α : Ty m ~> (S ~> <~ α)
K α β : (S ~> <~ α) β
K α β : (~> α) (<~ α) β = (α ~> (<~ α)) β = α ~> (β ~> α)
#+END_SRc

* Potential improvements to S type with new "substitution" vs "popping" mechanism

Now that substitution is separated from "popping" (not sure what to call this lol), defining the type of S may be simpler, since we may be able to "backtrack."

S \alpha \beta \gamma : (\alpha ~> \beta ~> \gamma) ~> (\alpha ~> \beta) ~> (\alpha ~> \gamma)

Now that we seperate substitution, we may be able to leverage the type of x to define the type of y and z.

We still have access to our mk_tx function defined above.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx

S \alpha \beta \gamma : Ty m ~> Ty n ~> Ty o ~> (\alpha ~> \beta ~> \gamma)

S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> ((\alpha ~> \beta ~> \gamma) x)
S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> ((\alpha ~> \beta ~> \gamma) x)

It would be really cool if we had some primitive to manipulate types. That is, if we could just drop the ~> \gamma from the type of x, we can easily make the type of y.

S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> (\alpha ~> \beta ~> \gamma) ~> (some transformation to remove \gamma (M x))

A potential way to remove \gamma from (M x): we can bubble down a K into its type.

This doesn't get us anywhere, since the evaluation rule for ~> puts our argument after the type.

S α β γ x : Ty m ~> Ty n ~> Ty o ~> (α ~> β ~> γ) ~> (M x)

I don't want to just add random evaluation rules to fix this issue.

Theoretically we could change the order of the arguments.
If we put z first (HIGHLY UNORTHODOX), we can build the type of x out of y and z.
BUT, this is suboptimal, since it isn't true to SK.

Just run with it though.

S' α β γ : Ty m ~> Ty n ~> Ty o ~> α ~> (α ~> β) ~> γ

Here, we're not really doing any crazy duplication. We can just form the type α ~> β ~> γ from the arguments we have.

If we have α, we can easily make α ~> β.

Going back to our mk_tx, mk_ty, mk_tz, we can probably copy all of our arguments into these. 

We can probably alter our little type maker combinators to not require all 3 arguments.

mk_tx just takes in α β and γ.
mk_ty just takes in α and β
mk_tz just takes in α and γ

Really, the only thing we need to copy three times is α.

Here, we copy α 3 times.
S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

S α : Ty m ~> Ty n ~> Ty o ~> ((α ~>) (α ~>)) (α ~>) = (α ~> (α ~>)) (α ~>)

Recall that there is actually an evaluation rule here we need to do, since we're passing an argument to α ~> (α ~>)

(α ~> (α ~>)) (α ~>) = α ~> (α ~> (α ~>))

This is actually fine. We can copy β now. Would have to be something like:

S (~> α) (~> α) β = (α ~> β) (α ~> β)

And then from here, we can embed logic into the left and right α ~> β to reject or accept γ.

(α ~> (~> β)) (α ~> (K β))

If we pass in γ, we get:

S (α ~> (~> β)) (α ~> (K β)) γ = (α ~> (β ~> γ)) (α ~> β)

This is exactly what we want.

So, going back to this step, how do we wrap it all together?

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

This step allows us to get α ~> (α ~> (α ~>))

Howver, note that associativity gives us:

(α ~>) (α ~> (α ~>))

This is fine.

We just need to put a placeholder in the third α ~> spot so we can fill it with β.

Something like:

(α ~>) (S (α ~> ) (K (α ~>)))

If we feed β into this we get:

S (α ~>) (S (α ~> ) (K (α ~>))) β = (α ~> β) ((α ~> β) (α ~>))

Now, since we're going to be copying in γ next, we just need to reject γ from the middle α ~> β

S (α ~>) (S (α ~> K) (K (α ~>))) β = (α ~> β) ((α ~> (K β)) (α ~>))

We also need to "accept" γ in the left α ~> β by turning α ~> β into α ~> (~> β). This is pretty easy.

S (α ~> ~>) (S (α ~> K) (K (α ~>))) β = (α ~> (~> β)) ((α ~> (K β)) (α ~>))

#7 Now, we can copy in γ.

S (S (α ~> (~> β)) ((α ~> (K β))) (α ~>) γ = (((α ~> (~> β)) γ) ((α ~> (K β)) γ) (α ~> γ) = (((α ~> β ~> γ) (α ~> β) (α ~> γ))

Technically, there is a reduction that can be done here.

(((α ~> β ~> γ) (α ~> β) (α ~> γ)) = (α ~> β ~> γ (α ~> β)) (α ~> γ)) = (α ~> β ~> γ (α ~> β) (α ~> γ)).

The only missing step is we need to append ~> in x and y.

Note, however, that we want these to be parnthesized correctly.

(α ~> β ~> γ (α ~> β) (α ~> γ)). = ~> α (~> β (~> γ (~> α β) (α ~> γ)

This is not really what we want. We want α ~> β ~> γ in parenthesis.

So really what we want is:

(~> α (~> β γ))

To recap:

1. Clone α 3 times

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>
S α : Ty m ~> Ty n ~> Ty o ~> (~> α) (~> α) (~> α)

This is perfect.

2. Rejection / accepting

We need to set up the first ~> α to accept β and γ, the second to reject γ, and the last to reject β.

Since β is the next argument, we must add the rejection logic in z and the type constructor logic in x and y.

We don't actually need "accept" logic in y. We just need to discard further arguments. K suffices.

S α : Ty m ~> Ty n ~> Ty o ~> (~> α (~>)) (~> α K) (~> α)

S : Ty m ~> Ty n ~> Ty o ~> S (S (<~# ~>) ~>) ~>
S α : Ty m ~> Ty n ~> Ty o ~> (α ~> (~>))  (~> α) (~> α)

Scratch:
S (<~# <~#) ~> α = (<~# ~> α) (~> α) = (α ~> (~>))  (~> α)

3. β accept x y

Using our new type, we can copy β. However, to copy β, we will need to nest the above expression in S.

Ideal:
S α β : Ty m ~> Ty n ~> Ty o ~> ((α ~> (~>)) β) ((~> α) β) (~> α)

We don't necessarily need to explicitly encode "rejection" of β in z.


S : Ty m ~> Ty n ~> Ty o ~> S (S (K S) (S (<~# ~>) ~>)) ~>
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S (<~# ~>) ~>)) α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (S (<~# ~>) ~> α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (S (<~# ~>) ~> α) (~> α)
S α β : Ty m ~> Ty n ~> Ty o ~> ((S (S (<~# ~>) ~> α) (~> α)

Our S is nested at the wrong level. We want to copy β. What's this extra S for again?


S : Ty m ~> Ty n ~> Ty o ~> S ((S (<~# ~>) ~>)) ~>
S α : Ty m ~> Ty n ~> Ty o ~> (((S (<~# ~>) ~>)) α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((((<~# ~>) α) (~> α))) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((((α ~> (~>)) (~> α))) (~> α)

This is looking pretty good. We want to be able to clone β once it gets passed through.

Note again the reduction here.
S α : Ty m ~> Ty n ~> Ty o ~> ((((α ~> (~>)) (~> α))) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> ((((α ~> (~> ~> α (~> α)))))

Idk what the hell is going on here. It clearlly is wrong. Lol.


Note that even in step #1, there is still a possible reduction
S α : Ty m ~> Ty n ~> Ty o ~> (~> α) (~> α) (~> α)
S α : Ty m ~> Ty n ~> Ty o ~> (~> (α (~> α (~> α)))
Very obviously not what we want. We need to separate these babys.

S α : Ty m ~> Ty n ~> Ty o ~> (~> α) ~> (~> α) ~> (~> α)

Something like this. Note, however, that if we do this, copying will be way harder. I think the best approach is:

S α : Ty m ~> Ty n ~> Ty o ~> S (S (~> α) (~> α)) (~> α)
S α β : Ty m ~> Ty n ~> Ty o ~> (α ~> β) (α ~> β) (α ~> β)

This is a general skeleton for how we do this.

Just note that this step, too, should produce some S expression.
Also note that z should reject β.

Rejecting:

(S (K K) ~>) α = K (~> α), all β will be rejected

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)

We can see here that β would be rejected from z, but γ would be accepted.

Fan out:

S : Ty m ~> Ty n ~> Ty o ~> S (S (K S) (S ~> ~>)) (S (K K) ~>)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S ~> ~>)) α) ((S (K K) ~>) α)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S ~> ~>)) α) (K (~> α))
S α : Ty m ~> Ty n ~> Ty o ~> (((S ((S ~> ~>) α)) (K (~> α))
S α : Ty m ~> Ty n ~> Ty o ~> (((S ((~> α) (~> α)) (K (~> α))
S α β : Ty m ~> Ty n ~> Ty o ~> (((S ((~> α) (~> α)) (K (~> α))
We need another S inside.
S α β : Ty m ~> Ty n ~> Ty o ~> (((~> α) (~> α) β) ((~> α))

S : Ty m ~> Ty n ~> Ty o ~> S (S (K S) (S (K S) (S ~> ~>))) (S (K K) ~>)
S α : Ty m ~> Ty n ~> Ty o ~> ((S (K S) (S (K S) (S ~> ~>))) α) (K (~> α))
S α : Ty m ~> Ty n ~> Ty o ~> ((S (S (α ~> (~> α))) (K (~> α))
S α β : Ty m ~> Ty n ~> Ty o ~> ((S (α ~> (~> α))) β) (~> α)
S α β : Ty m ~> Ty n ~> Ty o ~> ((S (α ~> (~> α))) β) (~> α)

I think the S is in the wrong place. It should be INSIDE the (α ~> ...) parenthesis.

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)
S α : Ty m ~> Ty n ~> Ty o ~> ((S ~> ~>) α) (K (~> α))
No, it's supposed to bbe like S (~> α) (~> α)

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)
S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) (S (K K) ~>)
S (M K) (M S) : ((Type 0 ~> (Type 1 ~> (Type 2 ~> (((S₀ ((S₀ ~>) ~>)) ((S₀ (K₀ K₀)) ~>)) (M K₀))))) (M S₀))

S (M K) (M S) (M M) : (((Type 0 ~> (Type 1 ~> (Type 2 ~> (((S₀ ((S₀ ~>) ~>)) ((S₀ (K₀ K₀)) ~>)) (M K₀))))) (M S₀)) (M M))

When we substitute, we should(?) reduce?
If we were to pop, we would reduce.
We should be lazy.

S (M K) (M S) (M M) : Type m ~> Type o ~> Type n ~> ((((((S₀ ~>) ~>) (M K₀)) (((S₀ (K₀ K₀)) ~>) (M K₀))) (M S₀)) (M M))

S (M K) (M S) (M M) : ((M K₀) ~> ((M K₀) ~> (((((S₀ (K₀ K₀)) ~>) (M K₀)) (M S₀)) (M M))))

We should be reducing here as well, idk why we're not.

S ? ? ? : (Type 0 ~> (Type 1 ~> (Type 2 ~> (? ~> (? ~> (? ~> ?))))))

S Ty 10 Ty 11 Ty 20 : (Type 0 ~> (Type 1 ~> (Type 2 ~> (Type 10 ~> (Type 10 ~> (Type 10 ~> Type 20))))))

Key idea:
- Fan out α β γ
- For each, "reject" or "accept"
- We already have utilities for this: mk_tx, mk_ty, and mk_tz

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> (α ~> γ)
Technically this is actually just:
(α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

Order of arguments is the same for all three. We just need to reject γ in y, and reject β in (α ~> γ)

We need to design 3 functions that take α β γ and produce their types. We already have this.

Gives us α ~> β ~> γ
def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

Gives us (α ~> β)
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

Gives us α ~> γ
def mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

To "compose these", we just need to put ~> around mk_tx, and ~> around mk_ty and mk_tyz
~> (mk_tx α β γ) ((~> mk_ty α β γ) (mk_tyz α β γ))

This gives our full type.
To combine these expressions, make a def.

def combine := ~>
combine left right = left ~> right

To combine all three given x y z,
~> ~>
~> ~> x y z = (~> ~> x) y z = (~> ~> (x y)) z
So we need
~> <~# x y z = (~> <~# x) y z = (<~# ~> x) y z = (x ~> ~>) y z = (x ~> (~> y)) z = (x ~> (y ~> x))

Exactly.

-- Combines x y z with ~>
Combine := ~> ~>

mk_tx, mk_ty, mk_z


Now, we need to "fan out" α β γ to each.
S (S mk_tx mk_ty) mk_tz
This will fan out α to all 3. But we want to fan out β and γ as well.

-- This is "fan out"
S (S (K S) (S (K S) (S (K K) S))) (K (S K K))

But, I don't really like this.

S (S mk_tx mk_ty) mk_tz α = (mk_tx α) (mk_ty α) (mk_tz α)

All of our type "maker" functions are combinators.
None of them individually use S.

We can modify mk_tx to prepend S inside mk_tx

Really, it would be great if we could avoid S altogether, but that's not happening.

This fan out shit is hella ugly, ngl.
We can embed S inside mk_tx and it may be nicer.

mk_tx α β γ = (α ~> β ~> γ)

mk_tx α = (<~# α) (<~# α)

Really, we don't need to actually fan out everything.

S : (α ~> β ~> γ) ~> (α ~> β) ~> (γ ~> α)

We definitely need to fan out α,
but we only need to fan out β and γ once.

We can actually change the type signatures of all three so they only take their proper arguments.

mk_ty := ~>
mk_tz := <~#

So now we can fan out α

S : S (S mk_tx mk_ty) mk_z
S α : (mk_tx α) (mk_ty α) (mk_z α)

Now we only have to fan out β and γ once.
Note that we have our nice ~> operator.

(t_in ~> t_out) arg = t_out arg, under type-checking, otherwise it's just (t_in ~> (t_out arg))

We can kinda separate our concerns by "pipelining" (mk_tx α) (mk_ty α) (mk_z α) with ~>
Type o ~> S (S mk_tx mk_ty) mk_z

This copies α into all three.
If we do our "combine" first, we can probably fix shit up.

(mk_tx α) ~> (mk_ty α) ~> (mk_tz α)

Passing in another value will ONLY put it into mk_tz α
~> kinda behaves like λ lowkey

We can change our type signature a bit. Instead of creating the whole type at once,
we can create (α ~> β ~> γ), but copy α β γ WHILE inside, and put that shit after ~>

S α β γ : Ty m ~> Ty o ~> Ty n ~> mk_tx

Pair := S (K (S I)) K

So,
(Pair (Pair mk_tx mk_ty) mk_tz) 

OHHHHH we can make a pair out of α β γ

S : Type 0 ~> Type 1 ~> Type 2 ~> Pair Pair Pair
Pair α β Pair = Pair α β
Pair (Pair α β) = S (K Pair) Pair 
S (K S (K Pair)) Pair α = (S (K Pair)) (Pair α)
S (K S (K Pair)) Pair α β = Pair (Pair α β)

S (K S (K Pair)) Pair - this is what we need to make ((α, β), γ)

((α, β), γ) (S (K ~>) ~>) = (S (K ~>) ~>) (α, β) γ
= ~> ((α, β) ~>) γ

We probably want (α, (β, γ)) instead


Pair (Pair α β)

S (K S (K Pair)) Pair α β = Pair (Pair α β)

Thsi is a ridiculous amount of abstraction.

Our mk_tx, mk_ty, mk_tz are pretty simple.
None of them have S.

We will need S somewhere.

We will probably need to use mk_tx, mk_ty, mk_tz.

However, we don't need to have all arguments for all of them.

mk_tx stays the same
mk_ty := ~>
mk_tz := <~#

Copying α to all 3 is easy

S (S mk_tx mk_ty) mk_z

Low-key copying is easy in general. We can keep the old arguments version if we want.

def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

Gives us (α ~> β)
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

Gives us α ~> γ
def mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

S (S mk_tx mk_ty) mk_tz

We just need to stick another S in front after, so like..

S (S (K S) (S mk_tx mk_ty)) mk_tz

So, this with α β =
S (S (K S) (S mk_tx mk_ty)) mk_tz α = S (mk_tx α mk_ty α) (mk_tz α)

Excellente. we need another S on the inside tho.
S (S (K S) (S mk_tx mk_ty)) mk_tz
S (S (K S) (S (K S) (S mk_tx mk_ty))) mk_tz

S (S (K S) (S (K S) (S mk_tx mk_ty))) mk_tz α = S (S ((mk_tx α) (mk_ty α)) (mk_tz α)

bruh.
This is NOT what we want. We want:
S (S (mk_tx α) (mk_ty α) (mk_tz α)


S (S (K S) (S mk_tx mk_ty)) mk_tz α = S (mk_tx α mk_ty α) (mk_tz α)

Im not even gonna lie man, writing out the types for this shit finna be insane.

S (S (K S) (S (S mk_tx) mk_ty)) mk_tz
S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz α = S (mk_tz α)

Checkpoint  1.

S (S (K S) (S mk_tx mk_ty)) mk_tz

((((mk_tx α) (mk_ty α)) β) ((mk_tz α) β))

Need to stick an S in the middle, like I said, but at least we know this one's working.

Sticking the S inside: checkpoint 2.

We want:
((((S (mk_tx α)) (mk_ty α)) β) ((mk_tz α) β))

This happens when we copy α.
Something like S (K S) mk_tx α = S (mk_tx α)

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz

with args, gives us:

((((mk_tx α) β) ((mk_ty α) β)) ((mk_tz α) β))

Checkpoint 2. Fanout with β works with all 3.

Now we just repeat the process one more time.

(S ((S ((mk_tx α) β)) ((mk_ty α) β)) ((mk_tz α) β))

This allows us to stick the S in front of mk_tx, but we need an outer one somewhere.
S (S (K S) (S (S (K S) (S (K S) mk_tx)) mk_ty)) mk_tz

Probably around the inner and mk_ty
S (S (K S) (S (S (K S) (S (S (K S) mk_tx)) mk_ty))) mk_tz

Gives us:

Where did \alpha go? Lol.

((((mk_tx γ) ((mk_ty β) γ)) ((β γ) ((mk_ty β) \gamma))) ((mk_tyz \beta) \gamma))

This copies \gamma to mk_tx and mk_ty
We need to copy at the outer layer, too.
S (S (K S) (S (S (K S) (S (K S) mk_tx)) mk_ty)) mk_tz

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz
S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz α
 = (((S (K S) (S (S (K S) mk_tx) mk_ty))) α) (mk_tz α)
= (S ((S (S (K S) mk_tx) mk_ty) α)) (mk_tz α)
= (S (((S (K S) mk_tx) α) (mk_ty α))) (mk_tz α)

At this step, we need to do what we did on the first step
? = (S (((S (mk_tx α) (mk_ty α))) (mk_tz α)

We need the α step to produce
S (S (K S) (S (S (K S) (mk_tx α)) (mk_ty α))) (mk_tz α)

α step currently produces this:
= (S (((S (K S) mk_tx) α) (mk_ty α))) (mk_tz α)
= (S ((S (mk_tx α)) (mk_ty α)) (mk_tz α)

We want:
S (S (K S) (S (S (K S) (S (K S) (mk_tx α))) (mk_ty α))) (mk_tz α)

We can change the original expression to:
S (S (K S) (S (S (K (S (K S))) mk_tx) mk_ty)) mk_tz
This adds the K S before (mk_tx α)
? = (S (((S (K S)) (mk_tx α)) (mk_ty α)) (mk_tz α)
S (S (K S) (S (S (K (S (K S))) mk_tx) mk_ty)) mk_tz

We need to stick another S (K S) before the child stuff inside
        ↓ this is where we stick the outer S in
        ↓        ↓ here, we stick the middle S (K S)
S (S (K S) (S (S (K (S (K S))) (S (K (S (K S))) mk_tx)) mk_ty)) mk_tz

Testing it out.

(((((mk_ty ((S₀ (K₀ (S₀ (K₀ S₀)))) mk_ty)) mk_tz) α) (((mk_x mk_ty) mk_z) α)) β)

Going back to checkpoint.

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz

with args, gives us:

((((mk_tx α) β) ((mk_ty α) β)) ((mk_tz α) β))

Shouldn't be hard to add γ.
We just need:

(S (S ((mk_tx α) β) ((mk_ty α) β)) ((mk_tz α) β))

S (S (K S) (S (S (K S) mk_tx) mk_ty)) mk_tz

Is there a smarter way of doing this?

Just copy α like: (~> α) (~> α) (~> α)

Then propogate β and reject from the last one:

 (α ~> ~>) (α ~> K) (K (~> α))

Need to copy tho.

In an expression like:
(~>) ~> (~>), it would be cool if in one pass you could copy the argument to all arrows

Basically every arrow that doesn't have an entry gets one.

This is only different from our current system in that we'd go down the left tree as well.

This shouldn't really be a problem, since types should be popped anyway.

Let's take an example:

S : Ty m ~> Ty o ~> Ty n ~> (~> ~>)
S α : (Ty m α) ~> (Ty o α) ~> (Ty n α) ~> ((~> α) (~> α))

This is low-key cracked.
Does this break our current K typing?

K : Ty m ~> Ty n ~> (S (~>) (<~#))
K α : (Ty m) α ~> (Ty n α) ~> (S (~>) (<~#) α)
K α : (Ty m) α ~> (Ty n α) ~> (α ~> (<~# α))

No.

K Typing still works.
