* Sk plan

Limitations of old approaches:
- Can't extract a "truth value" from M
  - Can't distinguish well-typed M from ill-typed
  - *New approach: constructive proof - you cannot produce M e t if e is not well-typed, since M e t will not type-check otherwise*
- Typings of K and S are complex
- Typings of K and S are the same as K and S
- M e t is the term representing "e is well-typed with type t"

M (M e) = M e t if e is well-typed

* Arrow abstraction / interpretation

- The only "base" types we have are M K, M S, and M M
- These don't actually reduce to anything
- We can interpret M (K \alpha \beta) as \alpha \rightarrow \alpha \rightarrow \beta
- We can interpret S similarly
- What is K \alpha, though?
  - We can just say this is SKM[((M K) \alpha)]
- But how do we unify arrows and just regular shit?
  - Do we even have to?
- How do we handle the beta-equivalent case?

* Arrow combinator

This is the holy grail. Adding a first-class arrow combinator.

* Arrow combinator functionality

We would like to have evaluation rules for ~> that behave similarly to \forall. We can do this if we derive the ~> expression via evaluation rules
We can do this the pure combinator way now, but I don't like this.
Point-free M K is nice.

* Fully dependent S and K, no partial M

K : #~>

K : #~>

K α : #~>

K α β : α ~> β
K α β x : α ~> 

K α β : #~> α β

K : S #~> #~>

K : #~>

K α : #~> α

K α : #~> α (#~> α)

K α β : #~> α (α β)

New S type just dropped?
There's this nice elimination we can do for this case
S : (#~> #~>) #~>
S α : α ~> (#~> #~>)
S α β : β ~> #~>
S α β γ : 

This is literally substitution.
We can just change the evaluation rule for ~>
such that ~> doens't pop the body. It just passes the argument through the type.

Wait ayo. We only pop the body of the ~> when a function call happens. When there's an eval step.

(t_in ~> t_out) arg = t_in ~> (t_out arg)

So S : (#~> #~>) #~>

K : #~> #~>
K α : (#~> #~>) α
K \alpha : #~> ~> \alpha
K \alpha \beta : #~> ~> \alpha \beta

Now when we evaluate K \alpha \beta x, lhs type becomes
~> \alpha \beta

Well, technically K \alpha \beta x is not an "eval step", whatever that means.

(t_in ~> t_out) arg = = t_in ~> (t_out arg)
(t_out <~ t_in) arg = = t_in ~> (t_out arg)

I think this is fine. But when do we pop to just t_out arg?
Intuitively, whenever we have a reduction.

*OR, we pop when there are no #~> left to fill.*
^^ I like this one.

This should actually be defined the same for K and S.

K : Ty 0 ~> Ty 0 ~> (S #~> #~>)
K \alpha : Ty 0 ~> Ty 0 ~> (\alpha ~> ((#~> \alpha))
K \alpha \beta : Ty 0 ~> Ty 0 ~> (\alpha ~> (\alpha ~> \beta))
K \alpha \beta x : Ty 0 ~> (\alpha ~> (\alpha ~> \beta))

Why can't we keep popping per-arg?

K : Ty 0 ~> Ty 0 ~> (S #~> #~>)
K \alpha : Ty 0 ~> S #~> #~> \alpha
K \alpha \beta : \alpha ~> (\alpha ~> \beta)

There's some incongruency here causing this.
But popping per-arg is fine.

We would just like to flip ~> in this type.
We could theoretically just add a <~ combinator.
Or we can just rework this expression somehow.

With <~, it's really clean though.

K : Ty 0 ~> Ty 0 ~> (S #~> <~#)
K \alpha : Ty 0 ~> \alpha ~> (<~# \alpha)
K \alpha \beta : \alpha ~> (\beta ~> \alpha)

We need to actually return \alpha though and discard our argument, since when we add x as an argument, it gets fed in.
K \alpha \beta x : \alpha ~> (\beta ~> \alpha x)

This is fine, I think.
For ergonomics we may want to remove the weird K thing we have to do at the end.

So the eval rule for ~> is
(\alpha ~> \beta) x = \alpha ~> (\beta x)

Except we don't know when \beta is a normal value.
So we do actually need K in the type of K.

K \alpha : Ty 0 ~> \alpha ~> (<~# (K \alpha)))
K : Ty 0 ~> Ty 0 ~> (S #~> (S <~# 

K \alpha : Ty 0 ~> \alpha ~> (<~# \alpha)

Mwah. Chef's kiss.

K : S #~> #~>
K \alpha : \alpha ~> (#~> \alpha)
K \alpha \beta : 

Why don't we just pop the types eagerly?
Like whenever you supply an argument, you pop the type?
This makes things a lot more complicated.
Perhaps have both?

ALTHOUGH. We could just not pop anything at all, but define the type of M recursively so that it does the popping then.

Ok so what about S?
We can do this nice type instantiation now with our arguments.

The question is, do we choose:
S (\alpha \beta \gamma : Type) : (\alpha \rightarrow \beta \rightarrow \gamma) \rightarrow (\alpha \rightarrow \beta) \rightarrow (\alpha \rightarrow \gamma)

or

S (\alpha \beta \gamma : Type) : \alpha \rightarrow \beta \rightarrow \gamma


This is lowkey ass because we have ZERO type information about the next step of evaluation.
But if we capture that somehow...

S (\alpha \beta \gamma : Type) : 

ALthough now that I think about it, now that we have arrows for our K and S, we don't need to split this up. We can just use the canonical one.

We need to control the order these are filled in.
We need to copy \alpha in one step.

Now this one is unironically nontrivial. Lol.

Fun fact though, \alpha ~> \beta ~> (\alpha ~> \gamma) = S (#~> (#~> \beta)) (<~# \gamma) \alpha = ((\alpha ~> (#~> \beta))) (\alpha ~> \gamma)
Fun fact though, \alpha ~> \beta ~> (\alpha ~> \gamma) = S (#~> \beta) (<~# \gamma) \alpha = (\alpha ~> \beta) (\alpha ~> \gamma)
Perhaps we can somehow join all these things up with ~> at the end.

So, for example, S (\alpha ~> \beta ~> \gamma) (\alpha ~> \beta) <~# (\alpha ~> \gamma) = <~# (\alpha ~> \beta ~> \gamma) (<~# (\alpha ~> \beta))

S \alpha : Ty 0 ~> Ty 0 ~> 

S : Ty 0 ~> Ty 0 ~> Ty 0 ~> 

S : Ty ~> Ty ~> Ty ~> S Ty Ty Ty 
S \alpha : Ty ~> Ty ~> S Ty Ty Ty \alpha
S \alpha \beta : Ty ~> S Ty Ty Ty \alpha \beta
S \alpha \beta \gamma : (\alpha \gamma) (\beta \gamma)

S : Ty ~> Ty ~> Ty ~> S (S #~> #~>) #~>
S \alpha : Ty ~> Ty ~> ((S #~> #~>) \alpha) (#~> \alpha)
S \alpha : Ty ~> Ty ~> (\alpha ~> (#~> \alpha)) (#~> \alpha)

We can potentially build the types incrementally.
So instead of copying \alpha into the fully type at once, we build it out in each step.
We really just need to know the "next input type." Not ALL the input types.

S \alpha \beta \gamma : (\alpha ~> \beta ~> \gamma) ~> 
X type has to match
S \alpha \beta \gamma x : #~> x
We need to "re-extract \alpha and \beta" from x. This is possible.
If we call x with some argument, the argument will be passed as a parameter to \gamma.

Ok, another strategy. We can build the type inside out.
We can build \alpha ~> \beta ~> \gamma out of y and (z : \alpha).
y : \alpha ~> \beta and z : \alpha 
So, theoretically, (M y) (<~# \gamma) = \alpha ~> \beta ~> \gamma

However, this is not predictive.
There is no specific reason why we can't have the types of S in reverse:
S : \alpha \beta \gamma, \alpha ~> (\alpha ~> \beta) ~> (\alpha ~> \beta ~> \gamma)
S \alpha \beta \gamma z y x = (x z) (y z)
However we're being extremely cheeky here, sine we haven't even constructed the types from the input type arguments.
We need to predict the ENTIRE type via the type arguments, then decompose.
We can add a new combinator for this if we want to. But I would prefer not to.

HOWEVER, like I said, we can build the type one argument at a time.
We just need to construct \alpha ~> \beta ~> \gamma first.

S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma) = ((#~> \alpha) (#~> \beta \gamma) = #~> #~>
S : <~# <~#
S \alpha = <~# <~# \alpha = \alpha #~> <#~
S \alpha \beta = \alpha #~> (<#~ \beta)
S \alpha \beta \gamma = \alpha ~> (\beta ~> \gamma)

So we know how to construt (\alpha ~> (\beta ~> \gamma)) now.
Getting (\alpha ~> \beta) is just popping the deepest nested \gamma, but we don't have an operation for that.

Creating \alpha ~> (\beta ~> \gamma) is pretty simple though. It's just <~# <~#.
So, logically, we can just copy \alpha and \beta when we do this.

S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)

Now, remember, we will pass x in, and it will be bubbled into \gamma.

"Return" within a ~>:

- When we're "finished" building a type, we need to "return" the value with K so that further type arguments don't get bubbled down.
For example, the type of K:

#+BEGIN_SRC lean
K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) <~#)
#+END_SRC

For \alpha \beta, this produces:

K \alpha \beta : (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) <~#) \alpha \beta
K \alpha \beta : (#~> \alpha) (<~# \alpha) \beta = \alpha ~> (<~# \alpha) \beta = \alpha ~> (\beta ~> \alpha)

For \alpha \beta x y, this produces:

K \alpha \beta x y : \alpha x y

This is not really what we wanted.
However, we can fix it in our (#~> \alpha) (<~# \alpha). Just replace the second one with (<~# (K \alpha))

However, we could potentially change the evaluation rules to handle this. Obviously, we should bubble if:

(t_in ~> t_out) arg

But theoretically, the output type might want to do something with the argument anyway. So we need to bring back !~>.

K \alpha \beta : (#~> \alpha) (<~# (K \alpha)) \beta
K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) (S (K <~#)) K))
K \alpha : Ty n ~> (\alpha ~> (<~# (K \alpha)))
K \alpha \beta :  (\alpha ~> (\beta ~> (K \alpha)))
K \alpha \beta x : \beta ~> (K \alpha x)
K \alpha \beta x y : (K \alpha x) y

K : Ty m ~> Ty n ~> (((((S m.succ n.succ m (M #~>)) (M <~#)) Ty m) #~>) (S (K <~#)) (S (K K) K)))

K \alpha : Ty n ~> (\alpha ~> ((S (K <~#)) (S (K K) K)) \alpha))
K \alpha : Ty n ~> (\alpha ~> (<~# (K (K \alpha))))
K \alpha \beta : \alpha ~> (\beta ~> (K (K \alpha)))
K \alpha \beta x : \beta ~> K \alpha
K \alpha \beta x y : K \alpha y = \alpha

We need another K. 

** Dependent S Typing

We know how to produce (\alpha ~> \beta ~> \gamma):

#+BEGIN_SRC lean
S : Type m ~> Type n ~> Type o ~> (<~# <~#)
S \alpha : Type n ~> Type o ~> (#~> #~>) \alpha
S \alpha : Type n ~> Type o ~> \alpha ~> (#~>)
S \alpha \beta : Type o ~> \alpha ~> (#~> \beta)
S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)
#+END_SRC

We can produce \alpha ~> (\beta ~> \gamma) easily.
We can also produce \alpha ~> \beta easily. But, producing all 3 is very difficult.
A possible strategy for (\alpha ~> \beta) ~> (\alpha ~> \gamma):

Note that \alpha is duplicated, while \beta and \gamma aren't.

This is in essence: S (<~ \beta) (<~ \gamma) \alpha = (\alpha ~> \beta) (\alpha ~> \gamma)

But what about the ~> in between? This would seem complicated, but we can construct (\alpha ~> \beta) ~> (\alpha ~> \gamma) by #~> (\alpha ~> \beta) ~> (\alpha ~> \gamma).

#+BEGIN_SRC
So, (S (K ~>) (S (<~ \beta) (<~ \gamma))) α = (~>)
#+END_SRC

However, this does not have the parenthesization we want.


S (<~ \beta) (<~ \gamma) \alpha

S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

The question is, do we even want this? We would like to be able to instantiate dependent types in shit like

(x z) (y z)

This typing appears to be just polymorphic.

We want:

S α β γ x y z : (((M x) z) (y z))

But we want to restrict inputs in some way.
S α β : (α ~> x_out) ~> (α ~> y_out) ~> S α 
S :  Ty 0 ~> Ty 0 ~> Ty 0 ~> (S Ty 0 Ty 0 Ty0)
S α β γ : (α γ) (β γ)

Really what we want is:
S α β γ x y z : (((M x) z) (y z))

This is not hard to achieve, but we need to restrict our inputs such that (x : α ~> ((M y) z))

But, we can't instantiate y and z, since we don't know what they are yet.

There isn't really a reason why we can't upgrade the type of S like such:

We can only really restrict types predictively.
We can't post-hoc restrict a type further. Or can we?
Really, I would like as minimal arguments to the function as possible.

What we want is:

S α β γ x y z : (α z) (y z)

Imagine they're popped off:

Ayo we're calling α here. Wtf.
This is possible if α is an arrow expression, because then it has type Ty.

- α z creates a new type
- y z creates a new term
- we can know the type of this already
- α z new type should expect ((M y) z) as an input
- So it's not clear what the type of x is immediately, since it expects y z as an input
- (y z) could be used to instantiate the type

- We can make assertions about x_out, though
- We may not be able to assert that the full type of x is α ~> β ~> γ,
but we can say that it expects α as an input, produces some output,

We can do type inference for S really easy:
M (S _ _ _ x y z) = ((M x) z) (y z)

Looking at this type, we can see x : M x, M x = α
We can see that α : γ 

S α β γ x y z : (α  ~> x_out) ~> (α ~> y_out) ~> α ~> (α z) (y z)

Also, another thing. Our typing judgment for α ~> β is kind of funky.
We really ought to separate the typing for ~> (pi) and →.
α → β is Ty whatever
while α ~> β is actually (M β). TODO

So, in ((M x) z) (y z),
(M x : α ~> 
(y : α ~> y_out)
(z : α)
(M x) : α ~> x_out
(x_out : (y_out α)

Is polymoprhic S actually polymorphic?
f
S α β γ : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ

There doesn't appear to be any dependency on terms in these types. Ngl.
Is this equivalent to ((M x) z) (y z)?

S α β γ x y z : (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ ~> ((M x) z) (y z)

y : α ~> β
x : α ~> (β α) ~> γ
z : α

S α β γ y_out : (α ~> (y_out α) ~> γ α)

"Polymorphic" S actually is dependent, since it's not actually polymorphic. ~> does all the heavy lifting.

S α β γ :  (α ~> β ~> γ) ~> (α ~> β) ~> α ~> γ
S α β γ x y z : ((M x) z) (y z)
S α β γ x y z : ((α ~> β ~> γ) z) (y z)
S α β γ x y z : (γ z) (y z)

On to actually making the S type.

**** S is dependent, but how do we construct its type?

We can construct a type of the form α ~> β ~> γ pretty easily.

S : Type m ~> Type n ~> Type o ~> (<~# <~#)
S \alpha : Type n ~> Type o ~> (#~> #~>) \alpha
S \alpha : Type n ~> Type o ~> \alpha ~> (#~>)
S \alpha \beta : Type o ~> \alpha ~> (#~> \beta)
S \alpha \beta \gamma : \alpha ~> (\beta ~> \gamma)

we'll say

def mk_t_x := Type m ~> Type n ~> Type o ~> (<~# <~#)

This makes α ~> (β ~> γ)

We can also make α ~> β. This is extremely simple. I'll use the same order of arguments, α β γ

def mk_ty := Type m ~> Type n ~> Type o ~> ~> ~>

mk_ty α β γ = ~> ~> α β γ = (~> ~> α) β γ = → ~> (α β) γ = (α β)

def mk_ty := Type m ~> Type n ~> Type o ~> ~> ~>

First with just α and β

def mk_ty_simple := Type m ~> Type n ~> ~>
mk_tysimple α β = α ~> β

Now we just discard γ.
def mk_ty := Type m ~> Type n ~> Type o ~> (<~# K)

^ Done.

mk_ty α β γ = (<~# K α β γ) = (α ~> K) β γ = (α ~> (K β)) γ = (α ~> β)


So, now we can construct (α ~> (β ~> γ)) and (α ~> β)

The rest of the type is literally just copiny γ and α.

Or, if we want, we can make a similar method to make this part of the call.

If we had something to "flip" K, that would be nice.
Or, alternatively, we can use →.
mk_ty_z α β γ := TYpe m ~> Type n ~> Type o ~> (#~> →)

^^ This works.

mk_ty_z α β γ = (~> →) α β γ = (→ ~> α) β γ = ~> α γ = α ~> γ

Ideally, we can compose these functions together to make the segments of the type.

We just need to duplicate α β γ each into each.
Let's make a α β γ "map" - this is just the functions we made


Catalogue: mk_t_x - (α ~> β ~> γ), mk_ty - (α ~> β), mk_tz - (α ~> γ)
Each of these accept α β γ as inputs.

To copy α, for example:
S mk_tx mk_ty α = (mk_tx α) (mk_ty α)
This is not particularly useful.

Simple algorithm: S already takes α β γ. We can use a fixpoint to duplicate in a way.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx
S α β γ = (α ~> β ~> γ) ~> 

Oh this is actually super simple.

Remember that (t_in ~> t_out) arg just pops one t_in, produces t_out arg
But we shouldn't just recurse like this forever.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx ~> mk_ty ~> mk_tz
S α : ~> Ty m (~> Ty n (~> Ty o (~> mk_tx (~> mk_ty mk_tz)

Evaluation here, α pops off the Ty m, we get (~> Ty n (~> Ty o (~> mk_tx (~> mk_ty mk_tz) α.
We don't want this to recurse forever. Our eval rule for (t_in ~> t_out) arg is broken. Really, it should be:
(t_in ~> t_out) arg = (t_in ~> t_out arg)
However, we should be able to use ((((M K) α β) x) y) and receive α

Quick recap of K type:

#+BEGIN_SRC lean
K : SKM[Ty m ~> Ty n ~> (((((S m.succ n.succ m (M (~>))) (M (<~))) Ty m) (~>)) (←))]
#+END_SRC

Same shit here, eval_once will work. K α : (Ty n ~> ...) α, but if we continue eval'ing this, we will pop ALL of the arguments.
We only want to pop once.

What happens if we fully evaluate K α?

#+BEGIN_SRC lean
K α : (((((S m.succ n.succ m (M (~>))) (M (<~))) Ty m) (~>)) (←)) α
K α : (~> α) (← α)
#+END_SRC

We can just insert Ty n deeper in here. We want Ty n ~> α (← α), such that
K α β : (α → α) α - this is wrong.

We could actually change the eval rues. We can just extend (t_in ~> t_out) arg := t_out arg to

t₁ ~> (t₂ ~> t₃) arg := (t₂ ~> (t₃ arg))
This is fine, ish, since now we're only ever obliviating one type.
Say we have t₁ ~> (t₂ ~> (t₃ ~> t₄)))), though

(t₁ ~> (t₂ ~> (t₃ ~> t₄))))) arg = (t₂ ~> ((t₃ ~> t₄) arg))

Ok, eval rules are fixed.

We could just algorithmically insert arg.

So, now, back to copying α β γ into our type constructors.

S (mk_tx mk_ty α = 

S : Ty m ~> Ty n ~> Ty o ~> 

S : (α ~> β ~> γ) ~> (α ~> β) ~> (α ~> γ)
S : Ty m ~> Ty n ~> Ty o ~> S (S mk_tx mk_ty) mk_tz

(S (S mk_tx mk_ty) mk_tz)  α β = (mk_tx α) (mk_ty α) (mk_tz α)

How do we do multiple variables tho...
S (S (mk_tx α) (mk_ty α)) (mk_tz α) β ..
this is the pattern.

How do we produce it?

(S (S (S mk_tx mk_ty)) mk_tz) α β = ((S (S mk_tx mk_ty)) α) (mk_tz α) = (S mk_tx mk_ty) (mk_tz α) (α (mk_tz α))

((S (S mk_t_x mk_t_y) mk_t_z) α) = ((S mk_t_x mk_t_y) α) (mk_t\z α) = ((mk_tx α) (mk_ty α)) (mk_t\z α)

S α : Ty n ~> Ty o ~> S (mk_tx α) (mk_ty α)
S α β : Ty o ~> S ((mk_tx α) β) ((mk_ty α) β)
S α β γ : (((mk_tx α) β) γ) (((mk_ty α) β) γ))

This is promising.



Other technique: we don't have to bbuild the type all at once. Do it in layers.

Or, hypothetically, we could extend our mk_twhatever with the ability to chain them together?

S α β γ : mk_t_x α β γ 

S (S (mk_t_x α β γ) (mk_t_y α β γ)) (mk_t_z α β γ) α β γ = (S (mk_t_x α β γ) (mk_t_y α β γ)) α (mk_t_z α β γ) α β γ
= (mk_t_x α) (mk_t_y α) (mk_t_z α) β γ

S (S (mk_t_x mk_t_y) (mk_t_z) α β γ

S (S mk_t_x mk_t_y) mk_t_z α β γ =
  (S mk_t_x mk_t_y) α (mk_tz α) β γ
= (mk_tx α) (mk_ty α) (mk_tz α) β γ

S (

Other approach, type by type

We can copy α here. We need to copy it three times.

S : Ty m ~> S (<~# <~# Ty n) (S ~> ~>)
S : Ty m ~> S (K (~> Ty n)) (S mk_tx mk_ty)
S α : S (K (~> Ty n)) (S mk_tx mk_ty) α = (~> Ty n) ((mk_tx α) (mk_ty α))

                                                                 ^ here
We want to add another layer for copying β in. We just need to insert an S

S : Ty m ~> S (K (~> Ty n)) (S (S (K S) mk_tx) mk_ty)
S α : Ty n ~> ((S (S (K S) mk_tx) mk_ty) α) = Ty n ~> ((S (mk_tx α) (mk_ty α)))
S α β = ((m_tx α) β) ((m_ty α) β)

Manually making this S type is going to be a fucking herculean task.

We already know we can make the type of x (α ~> β ~> γ).

Are there any other smart encodings we can come up with?

Really, the most important type is x. We just have to show that the rest are well-typed.

Once we have x as an input, we can test y and z using x,
since x has the type (α ~> β ~> γ).
We can probably even form (α ~> β) from it, since α ~> β ~> γ = (~> (~> (~> α) β) γ)
If we can inject K, we can do it.


S : Ty m ~> Ty n ~> Ty o ~> mk_tx ~> 

S : Ty m ~> S (K (~> Ty n)) (S (S (S (K (~> Ty o)) S) mk_tx) mk_ty)
S α : S (K (~> Ty n)) (S (S (S (K (~> Ty n)) S) mk_tx) mk_ty) α
    = (Ty n ~> (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α))

S α β : (Ty n ~> (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α)) β
    = (((S (S (S (K (~> Ty n)) S) mk_tx) mk_ty)) α) β
    = (S (S (K (~> Ty n)) S) mk_ty (mk_tx mk_ty) α β
    = ((S (K (~> Ty n)) mk_ty) (S mk_ty) (mk_tx mk_ty) α β
    = ((K (~> Ty n) (S mk_ty)) (mk_ty (S mk_ty)) (mk_tx mk_ty) α β
    = ((mk_ty (S mk_ty)) (mk_tx mk_ty)) α β

S with 3 fanouts:
S : Ty m ~> S (K (~> Ty n)) (S (S (S (K S) mk_tx) mk_ty) mk_tz)
S α : Ty n ~> ((S (S (S (K S) mk_tx) mk_ty) mk_tz) α)
S α β : (((S (S (S (K S) mk_tx) mk_ty) mk_tz) α) β)
        = ((S (S (K S) mk_tx) mk_ty) α) (mk_tz α) β
        = ((S (K S) mk_tx) α) (mk_ty α) (mk_tz α) β
        = ((K S) α) (mk_tx α) (mk_ty α) (mk_tz α) β
        = S (mk_tx α) (mk_ty α) (mk_tz α) β
        
        

S α : S mk_tx mk_ty α = (mk_tx α) (mk_ty α)
For S α β, we just do S (mk_tx α) (mk_ty α) β instead
Then same for S α β γ

I really feel like we ought to decouple substitution from popping.
If we just do (α ~> β) arg, we should just get (α ~> (β arg)),
but if we do M of a call, then we trigger popping.

Well, we're in a type, so we should trigger popping.
There's also another possibility which is that we introduce yet another arrow.
But I don't like this.

S α : (Ty n ~> α (α ~> (~> α))) 



S : Ty m ~> Ty n ~> Ty o ~> S 

We can chain these together by making mk_tx copy its arguments to a callee (golly gee this is getting really complicated though).


* When to trigger "substitution" vs popping

- (α ~> β) arg should be treated as substitution
- ((M e) arg) where (e : α ~> β) should invoke "popping"

This is a nice barrier between head reduction and reduction within the expression.

For example, with the type of K:

#+BEGIN_SRC lean
K α : Ty n ~> (((((S _m.succ n.succ _m (M (~>))) (M (<~))) Ty _m) (~>)) (←)) α
K α β : (((((S _m.succ n.succ _m (M (~>))) (M (<~))) Ty _m) (~>)) (←)) α β
K α β : (~> α) (← α) β = (α ~> (← α)) β = β → α
#+END_SRC

This would also simplify the typing of S significantly, since we would be able to manipuatel the full type of =S= in multiple passes without losing structure. Note, however, that items will still be popped in that case, since any arguments will necessarily invoke popping.

We gotta fix the K type, since it's discarding one of the α.

S α β γ : (α ~> β ~> γ) ~> whatever

This "no-pop feature" seems really important. Would make the typing for K really really clean.

Would be what I need to make this work.

#+BEGIN_SRC lean
K : Ty n ~> Ty m ~> S ~> <~
#+END_SRC

The question is, where do we pop if not in eval for (t_in ~> t_out) arg?
Most obvious candidate: evaluation, though this is not necessarily true.
Just type-checking a function call will probably invoke pop.
So, generalize to all function calls.

Essentially, (((M K) α β) x y) just does substitution, but (M (K α β x y)) does the actual popping.

So, the rule is M (lhs rhs), pop lhs's type.

The question is what to do about →?
I think the same should hold.

I really don't want to make this retarded like "pop" combinator. 
Is there a way to represent it?

Essentially taking an expression of the form α ~> β and turning it into β?
This is represented as ((~> α) β).
We don't necessarily need a pop combinator. If our left-hand-side type eval's to a ~>, we just pop it.

Popping is separate from substitution now.

Now, we can use this really nice K typing:

#+BEGIN_SRC lean
K : (Ty n ~> Ty m ~> S ~> <~)
K α : Ty m ~> (S ~> <~ α)
K α β : (S ~> <~ α) β
K α β : (~> α) (<~ α) β = (α ~> (<~ α)) β = α ~> (β ~> α)
#+END_SRc

* Potential improvements to S type with new "substitution" vs "popping" mechanism

Now that substitution is separated from "popping" (not sure what to call this lol), defining the type of S may be simpler, since we may be able to "backtrack."

S \alpha \beta \gamma : (\alpha ~> \beta ~> \gamma) ~> (\alpha ~> \beta) ~> (\alpha ~> \gamma)

Now that we seperate substitution, we may be able to leverage the type of x to define the type of y and z.

We still have access to our mk_tx function defined above.

S : Ty m ~> Ty n ~> Ty o ~> mk_tx

S \alpha \beta \gamma : Ty m ~> Ty n ~> Ty o ~> (\alpha ~> \beta ~> \gamma)

S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> ((\alpha ~> \beta ~> \gamma) x)
S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> ((\alpha ~> \beta ~> \gamma) x)

It would be really cool if we had some primitive to manipulate types. That is, if we could just drop the ~> \gamma from the type of x, we can easily make the type of y.

S \alpha \beta \gamma x : Ty m ~> Ty n ~> Ty o ~> (\alpha ~> \beta ~> \gamma) ~> (some transformation to remove \gamma (M x))

A potential way to remove \gamma from (M x): we can bubble down a K into its type.

This doesn't get us anywhere, since the evaluation rule for ~> puts our argument after the type.

S α β γ x : Ty m ~> Ty n ~> Ty o ~> (α ~> β ~> γ) ~> (M x)

I don't want to just add random evaluation rules to fix this issue.

Theoretically we could change the order of the arguments.
If we put z first (HIGHLY UNORTHODOX), we can build the type of x out of y and z.
BUT, this is suboptimal, since it isn't true to SK.

Just run with it though.

S' α β γ : Ty m ~> Ty n ~> Ty o ~> α ~> (α ~> β) ~> γ

Here, we're not really doing any crazy duplication. We can just form the type α ~> β ~> γ from the arguments we have.

If we have α, we can easily make α ~> β.

Going back to our mk_tx, mk_ty, mk_tz, we can probably copy all of our arguments into these. 

We can probably alter our little type maker combinators to not require all 3 arguments.

mk_tx just takes in α β and γ.
mk_ty just takes in α and β
mk_tz just takes in α and γ

Really, the only thing we need to copy three times is α.

Here, we copy α 3 times.
S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

S α : Ty m ~> Ty n ~> Ty o ~> ((α ~>) (α ~>)) (α ~>) = (α ~> (α ~>)) (α ~>)

Recall that there is actually an evaluation rule here we need to do, since we're passing an argument to α ~> (α ~>)

(α ~> (α ~>)) (α ~>) = α ~> (α ~> (α ~>))

This is actually fine. We can copy β now. Would have to be something like:

S (~> α) (~> α) β = (α ~> β) (α ~> β)

And then from here, we can embed logic into the left and right α ~> β to reject or accept γ.

(α ~> (~> β)) (α ~> (K β))

If we pass in γ, we get:

S (α ~> (~> β)) (α ~> (K β)) γ = (α ~> (β ~> γ)) (α ~> β)

This is exactly what we want.

So, going back to this step, how do we wrap it all together?

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

This step allows us to get α ~> (α ~> (α ~>))

Howver, note that associativity gives us:

(α ~>) (α ~> (α ~>))

This is fine.

We just need to put a placeholder in the third α ~> spot so we can fill it with β.

Something like:

(α ~>) (S (α ~> ) (K (α ~>)))

If we feed β into this we get:

S (α ~>) (S (α ~> ) (K (α ~>))) β = (α ~> β) ((α ~> β) (α ~>))

Now, since we're going to be copying in γ next, we just need to reject γ from the middle α ~> β

S (α ~>) (S (α ~> K) (K (α ~>))) β = (α ~> β) ((α ~> (K β)) (α ~>))

We also need to "accept" γ in the left α ~> β by turning α ~> β into α ~> (~> β). This is pretty easy.

S (α ~> ~>) (S (α ~> K) (K (α ~>))) β = (α ~> (~> β)) ((α ~> (K β)) (α ~>))

Now, we can copy in γ.

S (S (α ~> (~> β)) ((α ~> (K β))) (α ~>) γ = (((α ~> (~> β)) γ) ((α ~> (K β)) γ) (α ~> γ) = (((α ~> β ~> γ) (α ~> β) (α ~> γ))

These are all the components we need. We can merge them with ~> by:

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

Here,                                    ^ this is x

So, we can just change ~> in that position

S : Ty m ~> Ty n ~> Ty o ~> S (S ~> ~>) ~>

obviously.

How does this fit into what we've done so far?

